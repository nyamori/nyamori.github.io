<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>svc解码学习笔记</title>
    <link href="/2022/11/04/svc%E8%A7%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/04/svc%E8%A7%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录对H.264标准中解码相关的内容和OpenH264解码器相关的内容，用于学习笔记</p><p>H.264标准下载地址：</p><ol><li><a href="https://www.itu.int/rec/T-REC-H.264/recommendation.asp?lang=en&parent=T-REC-H.264-202108-I"><strong>H.264 (08&#x2F;21)</strong></a>，仅英语</li><li><a href="https://www.itu.int/rec/T-REC-H.264/recommendation.asp?lang=en&parent=T-REC-H.264-200503-S"><strong>H.264 (03&#x2F;05)</strong></a>，版本较老，有中文版</li></ol><p>OpenH264项目地址：</p><p>​<a href="https://github.com/cisco/openh264">OpenH264</a></p><h1 id="标准学习"><a href="#标准学习" class="headerlink" title="标准学习"></a>标准学习</h1><h2 id="概念记录"><a href="#概念记录" class="headerlink" title="概念记录"></a>概念记录</h2><h3 id="通用概念"><a href="#通用概念" class="headerlink" title="通用概念"></a>通用概念</h3><p>帧：一帧即一张图像，包括1个亮度矩阵和2个色度矩阵。</p><p>Slice：看官方中文版，翻译为条带；也有些翻译叫片。一个Slice包含了一个图像帧的全部或者部分数据，独立进行编解码。主要是防止误码的扩散用。</p><p>宏块：一个宏块包括一个16x16样本点的亮度块和两个对应的色度块。在YUV4:2:0的情况下，是一个16x16的亮度块+8x8的色度块</p><p>预测：由于图像信息之间存在相似性，在接收端，解码器可以通过指定方式预测图像信号。预测出的信号一般和实际信号有差异，这种差异被称之为残差。如果解码器知道残差（通过传输残差获取），那么解码器就可以通过残差进行信号的重建。</p><p>帧内预测：H.264的帧内预测，即利用图像空域的冗余，使用当前像素的邻近像素值预测像素的方式。</p><p>帧间预测：H.264的帧间预测，即利用图像时域的冗余，使用相邻帧的图像信号形成预测。在不同帧中，相似的宏块可能会发生移动，因此通常需要为每一个宏块定义运动矢量mv(x,y)。</p><p>分解与变换：图像中的大部分像素相似度很高，只有小部分像素具有丰富的细节，因此，图像中的低频信号多，高频信号少；将图像从空域变换到变换域，就会产生很多统计冗余，方便进行压缩编码。在H.264中一般使用离散余弦变换（DCT），其示例如下：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/%E4%B8%80%E4%B8%AA%E5%83%8F%E7%B4%A0%E5%9D%97%E5%8F%8A%E5%85%B6DCT%E5%8F%98%E6%8D%A2%E7%89%88%E6%9C%AC.png"></p><p>量化：量化是一种阶梯函数，将连续信号或者大量的离散信号处理为有限组合的电平。在H.264中通过量化步长控制量化的精度。</p><p>I帧，P帧和B帧：I帧即只使用帧内预测的帧；P帧可以使用帧内预测，也可以使用前向的帧作为参考进行帧间预测；B帧可以同时参考前向和后向的帧进行预测</p><p>VCL：视频编码层</p><p>NAL：网络提取层</p><p>SPS：参数序列集</p><p>PPS：图像序列集</p><p>GOP：一组连续的图像，开头为IDR帧。</p><h3 id="SVC专有的概念"><a href="#SVC专有的概念" class="headerlink" title="SVC专有的概念"></a>SVC专有的概念</h3><p>层：具有相同空域和质量域可伸缩行的一组NAL的集合</p><p>基本层：空域和质量域id为0</p><p>增强层：空域和质量域任一id大于0</p><p>层间预测：利用多层编码在空域上的冗余，使用基本层图像作为增强层图像的参考的图像的编码方式</p><p>层间帧内预测：使用基本层重建图像的上采样作为增强层图像的预测值</p><p>层间运动预测：使用基本层图像的参考索引，运动矢量，宏块类型，参考帧序号等的推导作为增强层的相应数值</p><p>层间残差预测：使用基本层图像的残差信号的上采样作为增强层的预测残差</p><p>帧内预测：相较AVC标准，SVC的帧内预测包括了层间帧内预测</p><p>EI Slice，EP Slice，EB Slice：增强层的slice，对应nalu type &#x3D; 20。</p><h2 id="解码流程"><a href="#解码流程" class="headerlink" title="解码流程"></a>解码流程</h2><p>H.264包含VCL层和NAL层，NAL层包裹着VCL层；解码H.264从解析NAL层开始。H.264标准对于解码过程中的计算有明确规定，并且要求对同一码流不同的解码器具有相同的结果（在编码器方面则完全没有规定，只规定需要输出满足要求的码流）。</p><p>整个解码过程的大致系统图如下：</p><p> <img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/AVC%E9%80%9A%E7%94%A8%E8%A7%A3%E7%A0%81%E7%B3%BB%E7%BB%9F.png" alt="AVC解码系统"></p><p>总的来说，解码的基本流程由以下几个步骤组成：</p><ol><li>解析NAL –&gt; 熵解码 –&gt; 重排序 –&gt; 反量化 –&gt; 反变换 –&gt; 残差数据</li><li>参考图像&#x2F;帧内宏块 –&gt; 预测数据</li><li>预测数据 + 残差数据 –&gt; 去块滤波 –&gt; 重建图像</li></ol><h2 id="NAL解析"><a href="#NAL解析" class="headerlink" title="NAL解析"></a>NAL解析</h2><p>H.264设计NAL层，专门用于网络传输，其基本单元是NALU（NAL Unit）。每一个NAL单元都包括1个字节的NAL头部和剩下的RBSP部分，根据NAL类型的不同，RBSP的内容有所不同；在特定NAL类型下，在NAL头部后一般会紧接数个字节的NAL头部扩展，然后才是RBSP内容，例如SVC扩展下类型14和20会有3字节的SVC扩展头部。NAL层组成示意图如下：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/AVC%E7%9A%84nal%E7%BB%93%E6%9E%84.png"></p><p>NAL头部标注了RBSP的类型，主要划分为VCL和non-VCL两种，在AVC当中NAL类型1-5就是VCL单元，其他是non-VCL单元，在SVC扩展中添加了NAL类型14和20，其中14是non-VCL单元，20是VCL单元。每种RBSP根据类型有专门的解析语法。在目前实际使用中，包括SVC标准在内，比较常见的NAL类型是1（非IDR帧基本都是1，暂时没见过2、3、4），5（IDR帧），6（SEI），7（SPS），8（PPS），14（Prefix NAL），15（subset SPS），20（scalable extension）。</p><p>NAL Header的结构如下：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/AVC_NAL_HEADER.png"></p><p>SVC扩展头部的结构如下：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/SVC%E7%BC%96%E7%A0%81NAL%E5%A4%B4%E9%83%A8%E6%89%A9%E5%B1%95.png"></p><p>NAL 解析的流程如下：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/NAL%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B.png"></p><h2 id="non-VCL解析"><a href="#non-VCL解析" class="headerlink" title="non-VCL解析"></a>non-VCL解析</h2><p>本节涉及NAL类型7（SPS），8（PPS），14（Prefix NAL unit），15 （Subset SPS）；暂时不讨论SEI信息的解析。</p><p>non-VCL的NAL单元分为多种，SPS和PPS是解码必须的参数集；Prefix NAL单元携带了下一个NAL单元的可伸缩信息，应当被视为和下一个NAL单元为同一个。</p><h3 id="Prefix-NAL-unit解析"><a href="#Prefix-NAL-unit解析" class="headerlink" title="Prefix NAL unit解析"></a>Prefix NAL unit解析</h3><p>prefix nal unit具有3个bytes的svc扩展头，其后接对应的RBSP。如图：</p><p>![](<a href="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/SVC%E7%9A%84prefix">https://nyamori.oss-cn-shanghai.aliyuncs.com/img/SVC的prefix</a> nal的rbsp.png)</p><h3 id="参数集解析"><a href="#参数集解析" class="headerlink" title="参数集解析"></a>参数集解析</h3><h4 id="SPS序列参数集"><a href="#SPS序列参数集" class="headerlink" title="SPS序列参数集"></a>SPS序列参数集</h4><p>sps的内容主要是seq_parameter_set_data，位于标准<strong>7.3.2.1.1</strong>一节。</p><h4 id="PPS图像参数集"><a href="#PPS图像参数集" class="headerlink" title="PPS图像参数集"></a>PPS图像参数集</h4><p>ps的内容主要是pic_parameter_set_rbsp，位于标准<strong>7.3.2.2</strong>一节。</p><h4 id="Subset-SPS"><a href="#Subset-SPS" class="headerlink" title="Subset SPS"></a>Subset SPS</h4><p>subset SPS在SVC当中，就是增强层的SPS扩展，除了SPS以外，还携带了对应的扩展。其RBSP如图所示：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/SVC%E7%9A%84SubsetSPS%E7%9A%84RBSP.png"></p><h2 id="VCL解析"><a href="#VCL解析" class="headerlink" title="VCL解析"></a>VCL解析</h2><p>本节涉及NAL类型1，5，20。由于没有特殊的排布结构，这三种类型首先都是对Slice进行解析。</p><p>Slice也分为Slice的头部和实际的数据，Slice头部保存了全局的信息，用于在实际的宏块数据解析的时候使用。如图所示：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/AVC%E7%9A%84Slice%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p>在H.264标准中，第8章规定了AVC解码中需要处理的过程，附录G.8章规定了SVC解码过程中在AVC解码的基础上新增的流程，下面进行一些摘录：</p><h3 id="Slice解析过程"><a href="#Slice解析过程" class="headerlink" title="Slice解析过程"></a>Slice解析过程</h3><h4 id="POC计算"><a href="#POC计算" class="headerlink" title="POC计算"></a>POC计算</h4><p>POC即图像顺序号用于标识图像的播放顺序，同时用于在帧间预测时，标记参考图像的初始顺序。每一帧都有自己的POC，一个编码帧有两个图像顺序号，称为TopFieldOrderCnt和BottomFieldOrderCnt。这两个序号标明了图像的相对图像顺序，这个顺序相对于上一个IDR帧的第一个输出场。</p><p>因此可以理解为，对IDR帧，其POC对应的顺序号应该为0。当解析非IDR图像时，AVC使用pic_order_cnt_type（取值为0，1，2）去标识POC的计算方法，流程如下：</p><h4 id="MbToSliceGroupMap的计算"><a href="#MbToSliceGroupMap的计算" class="headerlink" title="MbToSliceGroupMap的计算"></a>MbToSliceGroupMap的计算</h4><p>在进行Slice解码之前，需要根据PPS和当前的Slice Header计算MbToSliceGroupMap。</p><p>这一节主要需要以下参数：</p><ul><li>num_slice_groups_minus1</li><li>sclice_groups_map_type</li><li>slice_groups_change_direction_flag</li></ul><p>当num_slice_groups_minus1 &#x3D; 0时，所有宏块属于同一个组，否则，根据以上参数查表进行计算，即可按照标准8.2.2.1 - 8.2.2.7的扫描方式获取MbToSliceGroupMap。</p><h4 id="参考列表的计算"><a href="#参考列表的计算" class="headerlink" title="参考列表的计算"></a>参考列表的计算</h4><p>在解码P Slice和B slice等使用帧间预测的slice时，需要进行参考列表的计算。</p><p>参考图像分为用frame_num标记的短期参考图像和长期参考帧图像索引标记。下面以P Slice为例，进行说明。</p><p>P Slice图像的参考图像列表为RefPicList0，在初始化完成并修改后，参考列表中的总条数为num_ref_idx_l0_active_minus1 + 1。</p><h5 id="图像编号的计算"><a href="#图像编号的计算" class="headerlink" title="图像编号的计算"></a>图像编号的计算</h5><p>这个处理需要计算以下变量：</p><ul><li>FrameNum</li><li>FrameNumWrap</li><li>PicNum</li><li>LongTermFrameIdx</li><li>LongTermPicNum</li></ul><p>计算过程如下：</p><ol><li>FrameNum &#x3D; frame_num (来自短期参考图像列表的slice header)</li><li>FrameNumWarp &#x3D; （FrameNum &gt; 当前图像的frame_num）? FrameNum - MaxFrameNum : FrameNum</li><li>PicNum &#x3D; FrameNumWrap</li><li>LongTermPicNum &#x3D; LongTermFrameIdx</li></ol><h5 id="RefPicList0的初始化"><a href="#RefPicList0的初始化" class="headerlink" title="RefPicList0的初始化"></a>RefPicList0的初始化</h5><ol><li>排序RefPicList0，使得短期参考帧的序号比长期参考帧的小</li><li>短期参考帧按照PicNum递减</li><li>长期参考帧按照LongTermPicNum递增</li></ol><h5 id="参考帧重排序"><a href="#参考帧重排序" class="headerlink" title="参考帧重排序"></a>参考帧重排序</h5><p>产生初始化的参考列表后，需要根据slice_header中解析的值进行重排序。流程如图：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/AVC%E7%9A%84slice%E8%A7%A3%E7%A0%81%E6%98%AF%E5%8F%82%E8%80%83%E5%88%97%E8%A1%A8%E9%87%8D%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B.png"></p><h4 id="已解码图像的标记过程"><a href="#已解码图像的标记过程" class="headerlink" title="已解码图像的标记过程"></a>已解码图像的标记过程</h4><p>解码完成的图像，需要存储起来作为后续解码的参考图像。当nal_ref_idc &#x3D; 0，解码出的图像不会作为参考图像，无须标记；当nal_ref_idc &gt; 0, 图像成为参考图像时，需要进行标记，被标记为短期参考帧或者长期参考帧。其流程图如下：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/AVC%E8%A7%A3%E7%A0%81%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%82%E8%80%83%E5%B8%A7%E7%9A%84%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B.png"></p><h3 id="宏块解析过程"><a href="#宏块解析过程" class="headerlink" title="宏块解析过程"></a>宏块解析过程</h3><p>宏块是H.264编码的基本单元，对宏块进行预测，主要分为帧内预测和帧间预测。</p><p>宏块的主要句法属性摘录如下：</p><ul><li>mb_type，宏块切割方式</li><li>mb_pred，宏块预测类型</li><li>mb_sub_pred，子宏块的预测类型</li><li>coded_block_pattern，经常缩写为cbp，指出8x8子块的编码系数</li><li>mb_qp_delta：量化系数偏移量</li></ul><h4 id="帧内预测"><a href="#帧内预测" class="headerlink" title="帧内预测"></a>帧内预测</h4><ul><li>I_PCM模式，直接恢复像素值</li><li>其他AVC预测模式：Intra_16x16, Intra8x8, Intra_4x4</li><li>在SVC启用时，帧内预测需要判断base_mode_flag，当base_mode_flag &#x3D; 1时，进入层间帧内预测。此时多出一种IntraBL类型。</li></ul><h4 id="帧间预测"><a href="#帧间预测" class="headerlink" title="帧间预测"></a>帧间预测</h4><p>帧间预测模式使用运动补偿技术进行预测，总体流程如下：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/AVC%E5%B8%A7%E9%97%B4%E9%A2%84%E6%B5%8B%E8%A7%A3%E7%A0%81%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B.png"></p><p>其中，主要步骤是 运动矢量分量和参考索引推导 以及 帧间预测样点解码两部分。</p><h5 id="运动矢量分量和参考索引推导"><a href="#运动矢量分量和参考索引推导" class="headerlink" title="运动矢量分量和参考索引推导"></a>运动矢量分量和参考索引推导</h5><p>运动矢量的推导主要还是要参考宏块类型。</p><h5 id="帧间预测样点解码"><a href="#帧间预测样点解码" class="headerlink" title="帧间预测样点解码"></a>帧间预测样点解码</h5><p>根据标准预测即可。</p><h4 id="DCT反变换和反量化"><a href="#DCT反变换和反量化" class="headerlink" title="DCT反变换和反量化"></a>DCT反变换和反量化</h4><p>通过本节的操作，可以获取到实际图像和预测图像之间的残差矩阵。</p><h4 id="去块滤波"><a href="#去块滤波" class="headerlink" title="去块滤波"></a>去块滤波</h4><p>解码器在完成图像重建之后，通过去块滤波消除边界效应。</p><h3 id="SVC上采样"><a href="#SVC上采样" class="headerlink" title="SVC上采样"></a>SVC上采样</h3><p>SVC在启用层间预测之后，在三种预测方式中，分别需要进行基本层图像的上采样，运动矢量的上采样和残差的上采样。这些内容被规定在标准的G8.6节。</p><h4 id="层间运动预测的推导"><a href="#层间运动预测的推导" class="headerlink" title="层间运动预测的推导"></a>层间运动预测的推导</h4><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/%E5%B1%82%E9%97%B4%E8%BF%90%E5%8A%A8%E9%A2%84%E6%B5%8B%E7%9A%84%E4%B8%8A%E9%87%87%E6%A0%B7%E6%B5%81%E7%A8%8B.png"></p><h4 id="层间帧内预测的上采样"><a href="#层间帧内预测的上采样" class="headerlink" title="层间帧内预测的上采样"></a>层间帧内预测的上采样</h4><p>这里贴一下用于上采样的16抽头滤波器的矩阵：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/%E5%B1%82%E9%97%B4%E5%B8%A7%E5%86%85%E9%A2%84%E6%B5%8B%E7%94%A8%E7%9A%8416%E6%8A%BD%E5%A4%B4%E4%B8%8A%E9%87%87%E6%A0%B7%E6%BB%A4%E6%B3%A2%E5%99%A8.png"></p><h4 id="层间残差预测的上采样"><a href="#层间残差预测的上采样" class="headerlink" title="层间残差预测的上采样"></a>层间残差预测的上采样</h4><p>当前块类型是帧间块，并且residual_prediction_flag &#x3D; 1，此时存在层间残差预测。通过获取相应的8x8子宏块的残差信号，进行双线性滤波器的上采样，就可以作为增强层宏块的预测残差信号。</p><h1 id="OpenH264解码器学习"><a href="#OpenH264解码器学习" class="headerlink" title="OpenH264解码器学习"></a>OpenH264解码器学习</h1><p>OpenH264项目提供AVC解码能力并支持不带层间预测的空域SVC码流单层输入进行解码。</p><h2 id="主要涉及的文件"><a href="#主要涉及的文件" class="headerlink" title="主要涉及的文件"></a>主要涉及的文件</h2><p>解码器的核心内容位于<code>codec/decoder/core/src</code>目录下，主要包括以下文件：</p><ul><li>au_parser.cpp</li><li>bit_stream.cpp</li><li>cabac_decoder.cpp</li><li>deblocking.cpp &#x2F;&#x2F;去块滤波</li><li>decode_mb_aux.cpp</li><li>decoder_core.cpp &#x2F;&#x2F;解码核心流程</li><li>decoder.cpp</li><li>decoder_data_tables.cpp</li><li>decode_slice.cpp &#x2F;&#x2F;slice级别的解码</li><li>error_concealment.cpp &#x2F;&#x2F;差错隐藏</li><li>fmo.cpp</li><li>get_intra_predictor.cpp</li><li>manage_dec_ref.cpp</li><li>memmgr_nal_unit.cpp</li><li>mv_pred.cpp &#x2F;&#x2F;运动预测</li><li>parse_mb_syn_cabac.cpp</li><li>parse_mb_syn_cavlc.cpp</li><li>pic_queue.cpp</li><li>rec_mb.cpp</li><li>wels_decoder_thread.cpp</li></ul><h2 id="整体解码流程"><a href="#整体解码流程" class="headerlink" title="整体解码流程"></a>整体解码流程</h2><p>OpenH264项目在编译后，自带一个h264dec可执行程序，本节从该程序入手学习通用的解码循环。</p><h3 id="解码器调用循环"><a href="#解码器调用循环" class="headerlink" title="解码器调用循环"></a>解码器调用循环</h3><p>h264dec解码的调用如图所示：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/openh264%E8%A7%A3%E7%A0%81%E5%99%A8%E9%80%9A%E7%94%A8%E5%A4%A7%E5%BE%AA%E7%8E%AF.png"></p><p>OpenH264的解码器API设计的比较简单，主要就是遵循创建 –&gt; 初始化 –&gt; 解码 –&gt; 解初始化 –&gt; 销毁的流程进行调用。在解码上，提供了DecodeFrameNoDelay()和DecodeFrame2()等多种接口，但是最后调用到的是DecodeFrame2()。</p><h3 id="DecodeFrame2-内部流程"><a href="#DecodeFrame2-内部流程" class="headerlink" title="DecodeFrame2()内部流程"></a>DecodeFrame2()内部流程</h3><p>DecodeFrame2()是对DecodeFrame2WithCtx()的一个简单封装，后者的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">DECODING_STATE <span class="hljs-title">CWelsDecoder::DecodeFrame2WithCtx</span> <span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PWelsDecoderContext pDecContext, <span class="hljs-comment">//解码器句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* kpSrc,<span class="hljs-comment">//输入流</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">int</span> kiSrcLen,<span class="hljs-comment">//输入的长度</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>** ppDst,<span class="hljs-comment">//解码后的数据指针</span></span></span><br><span class="hljs-params"><span class="hljs-function">    SBufferInfo* pDstInfo)</span></span>;<span class="hljs-comment">//输出的解码数据的信息</span><br></code></pre></td></tr></table></figure><p>这个函数支持单线程解码也支持多线程解码，两者流程略有区别，以单线程解码为例，其处理流程如下：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/openh264%E8%A7%A3%E7%A0%81%E5%99%A8-decodeframe2.png"></p><p>整个流程也比较简单，真正的解码实现位于WelsDecodeBs()，这个函数是解码核心的入口函数。</p><h3 id="WelsDecodeBs-内部流程"><a href="#WelsDecodeBs-内部流程" class="headerlink" title="WelsDecodeBs()内部流程"></a>WelsDecodeBs()内部流程</h3><p>本函数的主要作用有以下几点：</p><ol><li>拷贝输入的比特流到内部缓存</li><li>解析内部缓存的比特流，并构建对应的access unit单元，完成解码</li></ol><p>其中，拷贝的过程和解析的过程是交织进行的，其流程图如下：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/openh264%E8%A7%A3%E7%A0%81%E5%99%A8-WelsDecodeBs.png"></p><p>图中解析NALU头部和非VCL单元的解析，按照标准规定的语法解析即可。NALU头部会解析1（不带svc扩展的nalu）或者4（带svc扩展的nalu type 14和type 20），然后根据NALU的类型，对内部的相应结构进行一定的初始化。<strong>同时，对于VCL数据，会解析Slice Header并存储，并完成POC计算、宏块映射的生成、参考帧相关的计算、参考图像的标记等解码步骤，这些都是按照标准文档进行计算的</strong>。非VCL的解析则包括SPS，PPS和Subset SPS按照标准的解析，并缓存相应数据到内部对应的结构当中。由图可以看到，解码的关键步骤在于被称为AU的单元的建立，其包含了解码过程，加上前后的准备和收尾工作，关键过程为一下三个：</p><ul><li>检查之前解码的情况，对应函数CheckAndFinishLastPic()</li><li>AU的建立，对应函数ConstructAccessUnit()</li><li>解码完成之后的更新，对应函数DecodeFinishUpdate()</li></ul><h4 id="CheckAndFinishLastPic-的处理"><a href="#CheckAndFinishLastPic-的处理" class="headerlink" title="CheckAndFinishLastPic()的处理"></a>CheckAndFinishLastPic()的处理</h4><p>本函数主要完成了两个功能：</p><ol><li>对之前解码状态的检查</li><li>错误隐藏处理</li></ol><p>暂时对这块的处理没有深入研究。</p><h4 id="ConstructAccessUnit-的处理"><a href="#ConstructAccessUnit-的处理" class="headerlink" title="ConstructAccessUnit()的处理"></a>ConstructAccessUnit()的处理</h4><p>这个函数的调用比较简单，这里直接贴代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ConstructAccessUnit</span><br><span class="hljs-comment"> * construct an access unit for given input bitstream, maybe partial NAL Unit, one or more Units are involved to</span><br><span class="hljs-comment"> * joint a collective access unit.</span><br><span class="hljs-comment"> * parameter\</span><br><span class="hljs-comment"> *  buf:        bitstream data buffer</span><br><span class="hljs-comment"> *  bit_len:    size in bit length of data</span><br><span class="hljs-comment"> *  buf_len:    size in byte length of data</span><br><span class="hljs-comment"> *  coded_au:   mark an Access Unit decoding finished</span><br><span class="hljs-comment"> * return:</span><br><span class="hljs-comment"> *  0 - success; otherwise returned error_no defined in error_no.h</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">ConstructAccessUnit</span> <span class="hljs-params">(PWelsDecoderContext pCtx, <span class="hljs-type">uint8_t</span>** ppDst, SBufferInfo* pDstInfo)</span> </span>&#123;<br>  <span class="hljs-type">int32_t</span> iErr = ERR_NONE;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetThreadCount</span> (pCtx) &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">//初始化</span><br>    iErr = <span class="hljs-built_in">InitConstructAccessUnit</span> (pCtx, pDstInfo);<br>    <span class="hljs-keyword">if</span> (ERR_NONE != iErr) &#123;<br>      <span class="hljs-keyword">return</span> iErr;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (pCtx-&gt;pCabacDecEngine == <span class="hljs-literal">NULL</span>) &#123;<br>    pCtx-&gt;pCabacDecEngine = (SWelsCabacDecEngine*)pCtx-&gt;pMemAlign-&gt;<span class="hljs-built_in">WelsMallocz</span> (<span class="hljs-built_in">sizeof</span> (SWelsCabacDecEngine),<br>                            <span class="hljs-string">&quot;pCtx-&gt;pCabacDecEngine&quot;</span>);<br>    <span class="hljs-built_in">WELS_VERIFY_RETURN_IF</span> (ERR_INFO_OUT_OF_MEMORY, (<span class="hljs-literal">NULL</span> == pCtx-&gt;pCabacDecEngine))<br>  &#125;<br><br>  <span class="hljs-comment">//解码</span><br>  iErr = <span class="hljs-built_in">DecodeCurrentAccessUnit</span> (pCtx, ppDst, pDstInfo);<br><br>  <span class="hljs-comment">//结束</span><br>  <span class="hljs-built_in">WelsDecodeAccessUnitEnd</span> (pCtx);<br><br>  <span class="hljs-keyword">if</span> (ERR_NONE != iErr) &#123;<br>    <span class="hljs-built_in">WelsLog</span> (&amp; (pCtx-&gt;sLogCtx), WELS_LOG_DEBUG, <span class="hljs-string">&quot;returned error from decoding:[0x%x]&quot;</span>, iErr);<br>    <span class="hljs-keyword">return</span> iErr;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> ERR_NONE;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，主要调用的接口为以下三个：</p><ul><li>InitConstructAccessUnit</li><li>DecodeCurrentAccessUnit</li><li>WelsDecodeAccessUnitEnd</li></ul><h5 id="AU的初始化和解码结束"><a href="#AU的初始化和解码结束" class="headerlink" title="AU的初始化和解码结束"></a>AU的初始化和解码结束</h5><ul><li>初始化部分，主要是有以下功能<ul><li>初始化AU部分参数</li><li>检查参数集</li><li>检查图像缓存的大小，并在必要时重分配</li></ul></li><li>解码结束，主要还需要做以下处理<ul><li>保存解码时候的nal，slice等的头部信息，供以后解码使用</li><li>清空当前解码句柄中不需要的RBSP的内存</li></ul></li></ul><h5 id="AU的解码"><a href="#AU的解码" class="headerlink" title="AU的解码"></a>AU的解码</h5><p>流程图如下：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/openh264%E8%A7%A3%E7%A0%81%E5%99%A8-AU%E7%9A%84%E8%A7%A3%E7%A0%81.png"></p><h4 id="DecodeFinishUpdate-的处理"><a href="#DecodeFinishUpdate-的处理" class="headerlink" title="DecodeFinishUpdate()的处理"></a>DecodeFinishUpdate()的处理</h4><p>本函数主要进行参数集（包括SPS，PPS和Subset SPS）和部分状态的更新。</p><h3 id="WelsDecodeSlice-的处理"><a href="#WelsDecodeSlice-的处理" class="headerlink" title="WelsDecodeSlice()的处理"></a>WelsDecodeSlice()的处理</h3><p>这个接口，根据Slice的类型分了6种处理，对slice内的宏块进行解码，包括IPB三种帧类型和cavlc&#x2F;cabac两种熵编码方式。这里不一一描述，其通用流程是类似的。其流程大致如下：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/openh264%E8%A7%A3%E7%A0%81%E5%99%A8-%E5%AE%8F%E5%9D%97%E8%A7%A3%E7%A0%81.png"></p><h2 id="重要数据结构"><a href="#重要数据结构" class="headerlink" title="重要数据结构"></a>重要数据结构</h2><h3 id="解码器句柄"><a href="#解码器句柄" class="headerlink" title="解码器句柄"></a>解码器句柄</h3><p>这个结构是整个解码流程的核心数据结构，同时很多解码用的数据结构内容均为指向该结构的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TagWelsDecoderContext</span> &#123;<br>  SLogContext sLogCtx;<br><span class="hljs-comment">// Input</span><br>  <span class="hljs-type">void</span>*<br>  pArgDec;                        <span class="hljs-comment">// structured arguments for decoder, reserved here for extension in the future</span><br><br>  SDataBuffer                   sRawData;<span class="hljs-comment">//内部缓存的比特流</span><br>  SDataBuffer                   sSavedData; <span class="hljs-comment">//for parse only purpose</span><br><br><span class="hljs-comment">// Configuration</span><br>  SDecodingParam*               pParam;<span class="hljs-comment">//解码参数</span><br>  <span class="hljs-type">uint32_t</span>                      uiCpuFlag;                      <span class="hljs-comment">// CPU compatibility detected</span><br><br>  VIDEO_BITSTREAM_TYPE eVideoType; <span class="hljs-comment">//indicate the type of video to decide whether or not to do qp_delta error detection.</span><br>  <span class="hljs-type">bool</span>                          bHaveGotMemory; <span class="hljs-comment">// global memory for decoder context related ever requested?</span><br><br>  <span class="hljs-type">int32_t</span>                       iImgWidthInPixel;       <span class="hljs-comment">// width of image in pixel reconstruction picture to be output</span><br>  <span class="hljs-type">int32_t</span>                       iImgHeightInPixel;<span class="hljs-comment">// height of image in pixel reconstruction picture to be output</span><br>  <span class="hljs-type">int32_t</span><br>  iLastImgWidthInPixel;   <span class="hljs-comment">// width of image in last successful pixel reconstruction picture to be output</span><br>  <span class="hljs-type">int32_t</span><br>  iLastImgHeightInPixel;<span class="hljs-comment">// height of image in last successful pixel reconstruction picture to be output</span><br>  <span class="hljs-type">bool</span> bFreezeOutput; <span class="hljs-comment">// indicating current frame freezing. Default: true</span><br><br><br><span class="hljs-comment">// Derived common elements</span><br>  SNalUnitHeader                sCurNalHead;<br>  EWelsSliceType                eSliceType;                     <span class="hljs-comment">// Slice type</span><br>  <span class="hljs-type">bool</span>                          bUsedAsRef;                     <span class="hljs-comment">//flag as ref</span><br>  <span class="hljs-type">int32_t</span>                       iFrameNum;<br>  <span class="hljs-type">int32_t</span>                       iErrorCode;                     <span class="hljs-comment">// error code return while decoding in case packets lost</span><br>  SFmo                          sFmoList[MAX_PPS_COUNT];        <span class="hljs-comment">// list for FMO storage</span><br>  PFmo                          pFmo;                           <span class="hljs-comment">// current fmo context after parsed slice_header</span><br>  <span class="hljs-type">int32_t</span>                       iActiveFmoNum;          <span class="hljs-comment">// active count number of fmo context in list</span><br><br>  <span class="hljs-comment">/*needed info by decode slice level and mb level*/</span><br>  <span class="hljs-type">int32_t</span><br>  iDecBlockOffsetArray[<span class="hljs-number">24</span>];     <span class="hljs-comment">// address talbe for sub 4x4 block in intra4x4_mb, so no need to caculta the address every time.</span><br><br>  <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">uint32_t</span>*  pMbType[LAYER_NUM_EXCHANGEABLE];                      <span class="hljs-comment">/* mb type */</span><br>    <span class="hljs-built_in">int16_t</span> (*pMv[LAYER_NUM_EXCHANGEABLE][LIST_A])[MB_BLOCK4x4_NUM][MV_A]; <span class="hljs-comment">//[LAYER_NUM_EXCHANGEABLE   MB_BLOCK4x4_NUM*]</span><br>    <span class="hljs-built_in">int8_t</span> (*pRefIndex[LAYER_NUM_EXCHANGEABLE][LIST_A])[MB_BLOCK4x4_NUM];<br>    <span class="hljs-built_in">int8_t</span> (*pDirect[LAYER_NUM_EXCHANGEABLE])[MB_BLOCK4x4_NUM];<br>    <span class="hljs-type">bool</span>*   pNoSubMbPartSizeLessThan8x8Flag[LAYER_NUM_EXCHANGEABLE];<br>    <span class="hljs-type">bool</span>*   pTransformSize8x8Flag[LAYER_NUM_EXCHANGEABLE];<br>    <span class="hljs-type">int8_t</span>* pLumaQp[LAYER_NUM_EXCHANGEABLE];        <span class="hljs-comment">/*mb luma_qp*/</span><br>    <span class="hljs-built_in">int8_t</span> (*pChromaQp[LAYER_NUM_EXCHANGEABLE])[<span class="hljs-number">2</span>];                                         <span class="hljs-comment">/*mb chroma_qp*/</span><br>    <span class="hljs-built_in">int16_t</span> (*pMvd[LAYER_NUM_EXCHANGEABLE][LIST_A])[MB_BLOCK4x4_NUM][MV_A]; <span class="hljs-comment">//[LAYER_NUM_EXCHANGEABLE   MB_BLOCK4x4_NUM*]</span><br>    <span class="hljs-type">uint16_t</span>* pCbfDc[LAYER_NUM_EXCHANGEABLE];<br>    <span class="hljs-built_in">int8_t</span> (*pNzc[LAYER_NUM_EXCHANGEABLE])[<span class="hljs-number">24</span>];<br>    <span class="hljs-built_in">int8_t</span> (*pNzcRs[LAYER_NUM_EXCHANGEABLE])[<span class="hljs-number">24</span>];<br>    <span class="hljs-built_in">int16_t</span> (*pScaledTCoeff[LAYER_NUM_EXCHANGEABLE])[MB_COEFF_LIST_SIZE]; <span class="hljs-comment">/*need be aligned*/</span><br>    <span class="hljs-built_in">int8_t</span> (*pIntraPredMode[LAYER_NUM_EXCHANGEABLE])[<span class="hljs-number">8</span>];  <span class="hljs-comment">//0~3 top4x4 ; 4~6 left 4x4; 7 intra16x16</span><br>    <span class="hljs-built_in">int8_t</span> (*pIntra4x4FinalMode[LAYER_NUM_EXCHANGEABLE])[MB_BLOCK4x4_NUM];<br>    <span class="hljs-type">uint8_t</span>* pIntraNxNAvailFlag[LAYER_NUM_EXCHANGEABLE];<br>    <span class="hljs-type">int8_t</span>*  pChromaPredMode[LAYER_NUM_EXCHANGEABLE];<br>    <span class="hljs-type">int8_t</span>*  pCbp[LAYER_NUM_EXCHANGEABLE];<br>    <span class="hljs-built_in">uint8_t</span> (*pMotionPredFlag[LAYER_NUM_EXCHANGEABLE][LIST_A])[MB_PARTITION_SIZE]; <span class="hljs-comment">// 8x8</span><br>    <span class="hljs-built_in">uint32_t</span> (*pSubMbType[LAYER_NUM_EXCHANGEABLE])[MB_SUB_PARTITION_SIZE];<br>    <span class="hljs-type">int32_t</span>* pSliceIdc[LAYER_NUM_EXCHANGEABLE];         <span class="hljs-comment">// using int32_t for slice_idc</span><br>    <span class="hljs-type">int8_t</span>*  pResidualPredFlag[LAYER_NUM_EXCHANGEABLE];<br>    <span class="hljs-type">int8_t</span>*  pInterPredictionDoneFlag[LAYER_NUM_EXCHANGEABLE];<br>    <span class="hljs-type">bool</span>*    pMbCorrectlyDecodedFlag[LAYER_NUM_EXCHANGEABLE];<br>    <span class="hljs-type">bool</span>*    pMbRefConcealedFlag[LAYER_NUM_EXCHANGEABLE];<br>    <span class="hljs-type">uint32_t</span> iMbWidth;<br>    <span class="hljs-type">uint32_t</span> iMbHeight;<br>  &#125; sMb; <span class="hljs-comment">//这块的内存在实际解码中由其他结构去引用</span><br><br><br><span class="hljs-comment">// reconstruction picture</span><br>  PPicture                      pDec;                   <span class="hljs-comment">//pointer to current picture being reconstructed</span><br><br>  PPicture<br>  pTempDec;               <span class="hljs-comment">//pointer to temp decoder picture to be used only for Bi Prediction.</span><br><br><span class="hljs-comment">// reference pictures</span><br>  SRefPic                       sRefPic;<br>  SRefPic                       sTmpRefPic; <span class="hljs-comment">//used to temporarily save RefPic for next active thread</span><br>  SVlcTable*                    pVlcTable;               <span class="hljs-comment">// vlc table</span><br><br>  SBitStringAux                 sBs;<br>  <span class="hljs-type">int32_t</span> iMaxBsBufferSizeInByte; <span class="hljs-comment">//actual memory size for BS buffer</span><br><br>  <span class="hljs-comment">/* Global memory external */</span><br>  SWelsDecoderSpsPpsCTX        sSpsPpsCtx;<br>  <span class="hljs-type">bool</span>                         bHasNewSps;<br><br>  SPosOffset sFrameCrop;<br><br>  PSliceHeader                  pSliceHeader;<br><br>  PPicBuff                      pPicBuff;       <span class="hljs-comment">// Initially allocated memory for pictures which are used in decoding.</span><br>  <span class="hljs-type">int32_t</span>                       iPicQueueNumber;<br><br>  PAccessUnit                   pAccessUnitList;        <span class="hljs-comment">// current access unit list to be performed</span><br>  <span class="hljs-comment">//PSps                          pActiveLayerSps[MAX_LAYER_NUM];</span><br>  PSps                          pSps;   <span class="hljs-comment">// used by current AU</span><br>  PPps                          pPps;   <span class="hljs-comment">// used by current AU</span><br><span class="hljs-comment">// Memory for pAccessUnitList is dynamically held till decoder destruction.</span><br>  PDqLayer<br>  pCurDqLayer;            <span class="hljs-comment">// current DQ layer representation, also carry reference base layer if applicable</span><br>  PDqLayer                      pDqLayersList[LAYER_NUM_EXCHANGEABLE];  <span class="hljs-comment">// DQ layers list with memory allocated</span><br>  PNalUnit                      pNalCur;          <span class="hljs-comment">// point to current NAL Nnit</span><br>  <span class="hljs-type">uint8_t</span>                       uiNalRefIdc;      <span class="hljs-comment">// NalRefIdc for easy access;</span><br>  <span class="hljs-type">int32_t</span>                       iPicWidthReq;             <span class="hljs-comment">// picture width have requested the memory</span><br>  <span class="hljs-type">int32_t</span>                       iPicHeightReq;            <span class="hljs-comment">// picture height have requested the memory</span><br><br>  <span class="hljs-type">uint8_t</span>                       uiTargetDqId;           <span class="hljs-comment">// maximal DQ ID in current access unit, meaning target layer ID</span><br>  <span class="hljs-comment">//bool                          bAvcBasedFlag;          // For decoding bitstream:</span><br>  <span class="hljs-type">bool</span>                          bEndOfStreamFlag;       <span class="hljs-comment">// Flag on end of stream requested by external application layer</span><br>  <span class="hljs-type">bool</span>                          bInstantDecFlag;        <span class="hljs-comment">// Flag for no-delay decoding</span><br>  <span class="hljs-type">bool</span>                          bInitialDqLayersMem;    <span class="hljs-comment">// dq layers related memory is available?</span><br><br>  <span class="hljs-type">bool</span>                          bOnlyOneLayerInCurAuFlag; <span class="hljs-comment">//only one layer in current AU: 1</span><br><br>  <span class="hljs-type">bool</span>                          bReferenceLostAtT0Flag;<br>  <span class="hljs-type">int32_t</span>                       iTotalNumMbRec; <span class="hljs-comment">//record current number of decoded MB</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LONG_TERM_REF</span><br>  <span class="hljs-type">bool</span>                          bParamSetsLostFlag;     <span class="hljs-comment">//sps or pps do not exist or not correct</span><br><br>  <span class="hljs-type">bool</span><br>  bCurAuContainLtrMarkSeFlag; <span class="hljs-comment">//current AU has the LTR marking syntax element, mark the previous frame or self</span><br>  <span class="hljs-type">int32_t</span>                       iFrameNumOfAuMarkedLtr; <span class="hljs-comment">//if bCurAuContainLtrMarkSeFlag==true, SHOULD set this variable</span><br><br>  <span class="hljs-type">uint16_t</span>                      uiCurIdrPicId;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-type">bool</span>       bNewSeqBegin;<br>  <span class="hljs-type">bool</span>       bNextNewSeqBegin;<br><br><span class="hljs-comment">//for Parse only</span><br>  <span class="hljs-type">bool</span> bFramePending;<br>  <span class="hljs-type">bool</span> bFrameFinish;<br>  <span class="hljs-type">int32_t</span> iNalNum;<br>  <span class="hljs-type">int32_t</span> iMaxNalNum; <span class="hljs-comment">//permitted max NAL num stored in parser</span><br>  SSpsBsInfo sSpsBsInfo [MAX_SPS_COUNT];<br>  SSpsBsInfo sSubsetSpsBsInfo [MAX_PPS_COUNT];<br>  SPpsBsInfo sPpsBsInfo [MAX_PPS_COUNT];<br>  SParserBsInfo* pParserBsInfo;<br><br>  <span class="hljs-comment">//PPicture pPreviousDecodedPictureInDpb; //pointer to previously decoded picture in DPB for error concealment</span><br>  PGetIntraPredFunc pGetI16x16LumaPredFunc[<span class="hljs-number">7</span>];          <span class="hljs-comment">//h264_predict_copy_16x16;</span><br>  PGetIntraPredFunc pGetI4x4LumaPredFunc[<span class="hljs-number">14</span>];           <span class="hljs-comment">// h264_predict_4x4_t</span><br>  PGetIntraPredFunc pGetIChromaPredFunc[<span class="hljs-number">7</span>];             <span class="hljs-comment">// h264_predict_8x8_t</span><br>  PIdctResAddPredFunc pIdctResAddPredFunc;<br>  PIdctFourResAddPredFunc pIdctFourResAddPredFunc;<br>  SMcFunc sMcFunc;<br>  <span class="hljs-comment">//Transform8x8</span><br>  PGetIntraPred8x8Func pGetI8x8LumaPredFunc[<span class="hljs-number">14</span>];<br>  PIdctResAddPredFunc  pIdctResAddPredFunc8x8;<br><br><span class="hljs-comment">//For error concealment</span><br>  SCopyFunc sCopyFunc;<br>  <span class="hljs-comment">/* For Deblocking */</span><br>  SDeblockingFunc     sDeblockingFunc;<br>  SExpandPicFunc      sExpandPicFunc;<br><br>  <span class="hljs-comment">/* For Block */</span><br>  SBlockFunc          sBlockFunc;<br><br>  <span class="hljs-type">int32_t</span> iCurSeqIntervalTargetDependId;<br>  <span class="hljs-type">int32_t</span> iCurSeqIntervalMaxPicWidth;<br>  <span class="hljs-type">int32_t</span> iCurSeqIntervalMaxPicHeight;<br><br>  PWelsFillNeighborMbInfoIntra4x4Func  pFillInfoCacheIntraNxNFunc;<br>  PWelsMapNeighToSample pMapNxNNeighToSampleFunc;<br>  PWelsMap16NeighToSample pMap16x16NeighToSampleFunc;<br><br><span class="hljs-comment">//feedback whether or not have VCL in current AU, and the temporal ID</span><br>  <span class="hljs-type">int32_t</span> iFeedbackVclNalInAu;<br>  <span class="hljs-type">int32_t</span> iFeedbackTidInAu;<br>  <span class="hljs-type">int32_t</span> iFeedbackNalRefIdc;<br><br>  <span class="hljs-type">bool</span> bAuReadyFlag;   <span class="hljs-comment">// true: one au is ready for decoding; false: default value</span><br><br>  <span class="hljs-type">bool</span> bPrintFrameErrorTraceFlag; <span class="hljs-comment">//true: can print info for upper layer</span><br>  <span class="hljs-type">int32_t</span> iIgnoredErrorInfoPacketCount; <span class="hljs-comment">//store the packet number with error decoding info</span><br><span class="hljs-comment">//trace handle</span><br>  <span class="hljs-type">void</span>*      pTraceHandle;<br><br>  PWelsLastDecPicInfo pLastDecPicInfo;<br><br>  SWelsCabacCtx sWelsCabacContexts[<span class="hljs-number">4</span>][WELS_QP_MAX + <span class="hljs-number">1</span>][WELS_CONTEXT_COUNT];<br>  <span class="hljs-type">bool</span> bCabacInited;<br>  SWelsCabacCtx   pCabacCtx[WELS_CONTEXT_COUNT];<br>  PWelsCabacDecEngine   pCabacDecEngine;<br>  <span class="hljs-type">double</span> dDecTime;<br>  SDecoderStatistics* pDecoderStatistics; <span class="hljs-comment">// For real time debugging</span><br>  <span class="hljs-type">int32_t</span> iMbEcedNum;<br>  <span class="hljs-type">int32_t</span> iMbEcedPropNum;<br>  <span class="hljs-type">int32_t</span> iMbNum;<br>  <span class="hljs-type">bool</span> bMbRefConcealed;<br>  <span class="hljs-type">bool</span> bRPLRError;<br>  <span class="hljs-type">int32_t</span> iECMVs[<span class="hljs-number">16</span>][<span class="hljs-number">2</span>];<br>  PPicture pECRefPic[<span class="hljs-number">16</span>];<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> uiTimeStamp;<br>  <span class="hljs-type">uint32_t</span>    uiDecodingTimeStamp; <span class="hljs-comment">//represent relative decoding time stamps</span><br><span class="hljs-comment">// To support scaling list HP</span><br>  <span class="hljs-type">uint16_t</span>  pDequant_coeff_buffer4x4[<span class="hljs-number">6</span>][<span class="hljs-number">52</span>][<span class="hljs-number">16</span>];<br>  <span class="hljs-type">uint16_t</span>  pDequant_coeff_buffer8x8[<span class="hljs-number">6</span>][<span class="hljs-number">52</span>][<span class="hljs-number">64</span>];<br>  <span class="hljs-built_in">uint16_t</span> (*pDequant_coeff4x4[<span class="hljs-number">6</span>])[<span class="hljs-number">16</span>];<span class="hljs-comment">// 4x4 sclaing list value pointer</span><br>  <span class="hljs-built_in">uint16_t</span> (*pDequant_coeff8x8[<span class="hljs-number">6</span>])[<span class="hljs-number">64</span>];<span class="hljs-comment">//64 residual coeff ,with 6 kinds of residual type, 52 qp level</span><br>  <span class="hljs-type">int</span> iDequantCoeffPpsid;<span class="hljs-comment">//When a new pps actived, reinitialised the scaling list value</span><br>  <span class="hljs-type">bool</span> bDequantCoeff4x4Init;<br>  <span class="hljs-type">bool</span> bUseScalingList;<br>  CMemoryAlign*     pMemAlign;<br>  <span class="hljs-type">void</span>* pThreadCtx;<br>  <span class="hljs-type">void</span>* pLastThreadCtx;<br>  WELS_MUTEX* pCsDecoder;<br>  <span class="hljs-type">int16_t</span> lastReadyHeightOffset[LIST_A][MAX_REF_PIC_COUNT]; <span class="hljs-comment">//last ready reference MB offset</span><br>  PPictInfo               pPictInfoList;<br>  PPictReoderingStatus    pPictReoderingStatus;<br>&#125; SWelsDecoderContext, *PWelsDecoderContext;<br></code></pre></td></tr></table></figure><h3 id="解码参数"><a href="#解码参数" class="headerlink" title="解码参数"></a>解码参数</h3><p>这里只可以指定目标空域，后面可以新增指定目标时域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* @brief SVC Decoding Parameters, reserved here and potential applicable in the future</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TagSVCDecodingParam</span> &#123;<br>  <span class="hljs-type">char</span>*     pFileNameRestructed;       <span class="hljs-comment">///&lt; file name of reconstructed frame used for PSNR calculation based debug</span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>  uiCpuLoad;             <span class="hljs-comment">///&lt; CPU load</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> uiTargetDqLayer;       <span class="hljs-comment">///&lt; setting target dq layer id</span><br><br>  ERROR_CON_IDC eEcActiveIdc;          <span class="hljs-comment">///&lt; whether active error concealment feature in decoder</span><br>  <span class="hljs-type">bool</span> bParseOnly;                     <span class="hljs-comment">///&lt; decoder for parse only, no reconstruction. When it is true, SPS/PPS size should not exceed SPS_PPS_BS_SIZE (128). Otherwise, it will return error info</span><br><br>  SVideoProperty   sVideoProperty;    <span class="hljs-comment">///&lt; video stream property</span><br>&#125; SDecodingParam, *PDecodingParam;<br></code></pre></td></tr></table></figure><h3 id="图像结构"><a href="#图像结构" class="headerlink" title="图像结构"></a>图像结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SPicture</span> &#123;<br>  <span class="hljs-comment">/************************************payload data*********************************/</span><br>  <span class="hljs-type">uint8_t</span>*        pBuffer[<span class="hljs-number">4</span>];             <span class="hljs-comment">// pointer to the first allocated byte, basical offset of buffer, dimension:</span><br>  <span class="hljs-type">uint8_t</span>*        pData[<span class="hljs-number">4</span>];               <span class="hljs-comment">// pointer to picture planes respectively</span><br>  <span class="hljs-type">int32_t</span>         iLinesize[<span class="hljs-number">4</span>];<span class="hljs-comment">// linesize of picture planes respectively used currently</span><br>  <span class="hljs-type">int32_t</span>         iPlanes;                        <span class="hljs-comment">// How many planes are introduced due to color space format?</span><br><span class="hljs-comment">// picture information</span><br><br>  <span class="hljs-comment">/*******************************from EC mv copy****************************/</span><br>  <span class="hljs-type">bool</span> bIdrFlag;<br><br>  <span class="hljs-comment">/*******************************from other standard syntax****************************/</span><br>  <span class="hljs-comment">/*from sps*/</span><br>  <span class="hljs-type">int32_t</span>         iWidthInPixel;  <span class="hljs-comment">// picture width in pixel</span><br>  <span class="hljs-type">int32_t</span>         iHeightInPixel;<span class="hljs-comment">// picture height in pixel</span><br>  <span class="hljs-comment">/*from slice header*/</span><br>  <span class="hljs-type">int32_t</span>         iFramePoc;              <span class="hljs-comment">// frame POC</span><br><br>  <span class="hljs-comment">/*******************************sef_definition for misc use****************************/</span><br>  <span class="hljs-type">bool</span>            bUsedAsRef;                                                     <span class="hljs-comment">//for ref pic management</span><br>  <span class="hljs-type">bool</span>            bIsLongRef;     <span class="hljs-comment">// long term reference frame flag       //for ref pic management</span><br>  <span class="hljs-type">int8_t</span>          iRefCount;<br><br>  <span class="hljs-type">bool</span>            bIsComplete;    <span class="hljs-comment">// indicate whether current picture is complete, not from EC</span><br>  <span class="hljs-comment">/*******************************for future use****************************/</span><br>  <span class="hljs-type">uint8_t</span>         uiTemporalId;<br>  <span class="hljs-type">uint8_t</span>         uiSpatialId;<br>  <span class="hljs-type">uint8_t</span>         uiQualityId;<br><br>  <span class="hljs-type">int32_t</span>         iFrameNum;              <span class="hljs-comment">// frame number                 //for ref pic management</span><br>  <span class="hljs-type">int32_t</span>         iFrameWrapNum;          <span class="hljs-comment">// frame wrap number            //for ref pic management</span><br>  <span class="hljs-type">int32_t</span>         iLongTermFrameIdx;                                      <span class="hljs-comment">//id for long term ref pic</span><br>  <span class="hljs-type">uint32_t</span>        uiLongTermPicNum;       <span class="hljs-comment">//long_term_pic_num</span><br><br>  <span class="hljs-type">int32_t</span>     iSpsId; <span class="hljs-comment">//against mosaic caused by cross-IDR interval reference.</span><br>  <span class="hljs-type">int32_t</span>     iPpsId;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> uiTimeStamp;<br>  <span class="hljs-type">uint32_t</span>    uiDecodingTimeStamp; <span class="hljs-comment">//represent relative decoding time stamps</span><br>  <span class="hljs-type">int32_t</span>     iPicBuffIdx;<br>  EWelsSliceType  eSliceType;<br>  <span class="hljs-type">bool</span>        bIsUngroupedMultiSlice; <span class="hljs-comment">//multi-slice picture with each each slice group contains one slice.</span><br>  <span class="hljs-type">bool</span> bNewSeqBegin;<br>  <span class="hljs-type">int32_t</span> iMbEcedNum;<br>  <span class="hljs-type">int32_t</span> iMbEcedPropNum;<br>  <span class="hljs-type">int32_t</span> iMbNum;<br><br>  <span class="hljs-type">bool</span>*    pMbCorrectlyDecodedFlag;<br>  <span class="hljs-built_in">int8_t</span> (*pNzc)[<span class="hljs-number">24</span>];<br>  <span class="hljs-type">uint32_t</span>*  pMbType; <span class="hljs-comment">// mb type used for direct mode</span><br>  <span class="hljs-built_in">int16_t</span> (*pMv[LIST_A])[MB_BLOCK4x4_NUM][MV_A]; <span class="hljs-comment">// used for direct mode</span><br>  <span class="hljs-built_in">int8_t</span> (*pRefIndex[LIST_A])[MB_BLOCK4x4_NUM]; <span class="hljs-comment">//used for direct mode</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SPicture</span>* pRefPic[LIST_A][<span class="hljs-number">17</span>];  <span class="hljs-comment">//ref pictures used for direct mode</span><br>  SWelsDecEvent* pReadyEvent;  <span class="hljs-comment">//MB line ready event</span><br><br>&#125;;<span class="hljs-comment">// &quot;Picture&quot; declaration is comflict with Mac system</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SPicture</span>* PPicture;<br></code></pre></td></tr></table></figure><h3 id="AU结构"><a href="#AU结构" class="headerlink" title="AU结构"></a>AU结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TagAccessUnits</span> &#123;<br>  PNalUnit*               pNalUnitsList;  <span class="hljs-comment">// list of NAL Units pointer in this AU</span><br>  <span class="hljs-type">uint32_t</span>                uiAvailUnitsNum;   <span class="hljs-comment">// Number of NAL Units available in each AU list based current bitstream,</span><br>  <span class="hljs-type">uint32_t</span>                uiActualUnitsNum;       <span class="hljs-comment">// actual number of NAL units belong to current au</span><br><span class="hljs-comment">// While available number exceeds count size below, need realloc extra NAL Units for list space.</span><br>  <span class="hljs-type">uint32_t</span>                uiCountUnitsNum;        <span class="hljs-comment">// Count size number of malloced NAL Units in each AU list</span><br>  <span class="hljs-type">uint32_t</span>                uiStartPos;<br>  <span class="hljs-type">uint32_t</span>                uiEndPos;<br>  <span class="hljs-type">bool</span>                    bCompletedAuFlag;       <span class="hljs-comment">// Indicate whether it is a completed AU</span><br>&#125; SAccessUnit, *PAccessUnit;<br></code></pre></td></tr></table></figure><h3 id="层结构"><a href="#层结构" class="headerlink" title="层结构"></a>层结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TagDqLayer</span>       SDqLayer;<br><span class="hljs-keyword">typedef</span> SDqLayer*               PDqLayer;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TagLayerInfo</span> &#123;<br>  SNalUnitHeaderExt             sNalHeaderExt;<br>  SSlice                        sSliceInLayer;  <span class="hljs-comment">// Here Slice identify to Frame on concept</span><br>  PSubsetSps                    pSubsetSps;     <span class="hljs-comment">// current pSubsetSps used, memory alloc in external</span><br>  PSps                          pSps;           <span class="hljs-comment">// current sps based avc used, memory alloc in external</span><br>  PPps                          pPps;           <span class="hljs-comment">// current pps used</span><br>&#125; SLayerInfo, *PLayerInfo;<br><span class="hljs-comment">/* Layer Representation */</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TagDqLayer</span> &#123;<br>  SLayerInfo                    sLayerInfo;<br><br>  PBitStringAux                 pBitStringAux;  <span class="hljs-comment">// pointer to SBitStringAux</span><br>  PFmo                          pFmo;           <span class="hljs-comment">// Current fmo context pointer used</span><br>  <span class="hljs-comment">/* 从这里开始下面的指针，真实的内存空间位于解码器句柄的sMb结构 */</span><br>  <span class="hljs-type">uint32_t</span>* pMbType;<br>  <span class="hljs-type">int32_t</span>* pSliceIdc;                           <span class="hljs-comment">// using int32_t for slice_idc</span><br>  <span class="hljs-built_in">int16_t</span> (*pMv[LIST_A])[MB_BLOCK4x4_NUM][MV_A];<br>  <span class="hljs-built_in">int16_t</span> (*pMvd[LIST_A])[MB_BLOCK4x4_NUM][MV_A];<br>  <span class="hljs-built_in">int8_t</span>  (*pRefIndex[LIST_A])[MB_BLOCK4x4_NUM];<br><span class="hljs-built_in">int8_t</span>(*pDirect)[MB_BLOCK4x4_NUM];<br>  <span class="hljs-type">bool</span>*    pNoSubMbPartSizeLessThan8x8Flag;<br>  <span class="hljs-type">bool</span>*    pTransformSize8x8Flag;<br>  <span class="hljs-type">int8_t</span>*  pLumaQp;<br>  <span class="hljs-built_in">int8_t</span> (*pChromaQp)[<span class="hljs-number">2</span>];<br>  <span class="hljs-type">int8_t</span>*  pCbp;<br>  <span class="hljs-type">uint16_t</span> *pCbfDc;<br>  <span class="hljs-built_in">int8_t</span> (*pNzc)[<span class="hljs-number">24</span>];<br>  <span class="hljs-built_in">int8_t</span> (*pNzcRs)[<span class="hljs-number">24</span>];<br>  <span class="hljs-type">int8_t</span>*  pResidualPredFlag;<br>  <span class="hljs-type">int8_t</span>*  pInterPredictionDoneFlag;<br>  <span class="hljs-type">bool</span>*    pMbCorrectlyDecodedFlag;<br>  <span class="hljs-type">bool</span>*    pMbRefConcealedFlag;<br>  <span class="hljs-built_in">int16_t</span> (*pScaledTCoeff)[MB_COEFF_LIST_SIZE];<br>  <span class="hljs-built_in">int8_t</span> (*pIntraPredMode)[<span class="hljs-number">8</span>];  <span class="hljs-comment">//0~3 top4x4 ; 4~6 left 4x4; 7 intra16x16</span><br>  <span class="hljs-built_in">int8_t</span> (*pIntra4x4FinalMode)[MB_BLOCK4x4_NUM];<br>  <span class="hljs-type">uint8_t</span>  *pIntraNxNAvailFlag;<br>  <span class="hljs-type">int8_t</span>*  pChromaPredMode;<br>  <span class="hljs-comment">//uint8_t (*motion_pred_flag[LIST_A])[MB_PARTITION_SIZE]; // 8x8</span><br>  <span class="hljs-built_in">uint32_t</span> (*pSubMbType)[MB_SUB_PARTITION_SIZE];<br>  <span class="hljs-type">int32_t</span> iLumaStride;<br>  <span class="hljs-type">int32_t</span> iChromaStride;<br>  <span class="hljs-type">uint8_t</span>* pPred[<span class="hljs-number">3</span>];<br>  <span class="hljs-type">int32_t</span> iMbX;<br>  <span class="hljs-type">int32_t</span> iMbY;<br>  <span class="hljs-type">int32_t</span> iMbXyIndex;<br>  <span class="hljs-type">int32_t</span> iMbWidth;               <span class="hljs-comment">// MB width of this picture, equal to sSps.iMbWidth</span><br>  <span class="hljs-type">int32_t</span> iMbHeight;              <span class="hljs-comment">// MB height of this picture, equal to sSps.iMbHeight;</span><br>  <span class="hljs-comment">/* 以上内容来自解码器句柄的sMb结构 */</span><br><br>  <span class="hljs-comment">/* Common syntax elements across all slices of a DQLayer */</span><br>  <span class="hljs-type">int32_t</span>                   iSliceIdcBackup;<br>  <span class="hljs-type">uint32_t</span>                  uiSpsId;<br>  <span class="hljs-type">uint32_t</span>                  uiPpsId;<br>  <span class="hljs-type">uint32_t</span>                  uiDisableInterLayerDeblockingFilterIdc;<br>  <span class="hljs-type">int32_t</span>                   iInterLayerSliceAlphaC0Offset;<br>  <span class="hljs-type">int32_t</span>                   iInterLayerSliceBetaOffset;<br>  <span class="hljs-comment">//SPosOffset              sScaledRefLayer;</span><br>  <span class="hljs-type">int32_t</span>                   iSliceGroupChangeCycle;<br><br>  PRefPicListReorderSyn     pRefPicListReordering;<br>  PPredWeightTabSyn         pPredWeightTable;<br>  PRefPicMarking            pRefPicMarking; <span class="hljs-comment">// Decoded reference picture marking syntaxs</span><br>  PRefBasePicMarking        pRefPicBaseMarking;<br><br>  PPicture                  pRef;                   <span class="hljs-comment">// reference picture pointer</span><br>  PPicture                  pDec;                   <span class="hljs-comment">// reconstruction picture pointer for layer</span><br><br><span class="hljs-type">int16_t</span>iColocMv[<span class="hljs-number">2</span>][<span class="hljs-number">16</span>][<span class="hljs-number">2</span>];     <span class="hljs-comment">//Colocated MV cache</span><br><span class="hljs-type">int8_t</span>iColocRefIndex[<span class="hljs-number">2</span>][<span class="hljs-number">16</span>];  <span class="hljs-comment">//Colocated RefIndex cache</span><br><span class="hljs-type">int8_t</span>iColocIntra[<span class="hljs-number">16</span>];  <span class="hljs-comment">//Colocated Intra cache</span><br><br>  <span class="hljs-type">bool</span>                      bUseWeightPredictionFlag;<br><span class="hljs-type">bool</span>                      bUseWeightedBiPredIdc;<br><span class="hljs-type">bool</span>                      bStoreRefBasePicFlag;                           <span class="hljs-comment">// iCurTid == 0 &amp;&amp; iCurQid = 0 &amp;&amp; bEncodeKeyPic = 1</span><br>  <span class="hljs-type">bool</span>                      bTCoeffLevelPredFlag;<br>  <span class="hljs-type">bool</span>                      bConstrainedIntraResamplingFlag;<br>  <span class="hljs-type">uint8_t</span>                   uiRefLayerDqId;<br>  <span class="hljs-type">uint8_t</span>                   uiRefLayerChromaPhaseXPlus1Flag;<br>  <span class="hljs-type">uint8_t</span>                   uiRefLayerChromaPhaseYPlus1;<br>  <span class="hljs-type">uint8_t</span>                   uiLayerDqId;                    <span class="hljs-comment">// dq_id of current layer</span><br>  <span class="hljs-type">bool</span>                      bUseRefBasePicFlag;     <span class="hljs-comment">// whether reference pic or reference base pic is referred?</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vscode设置随记</title>
    <link href="/2022/10/14/vscode%E8%AE%BE%E7%BD%AE%E9%9A%8F%E8%AE%B0/"/>
    <url>/2022/10/14/vscode%E8%AE%BE%E7%BD%AE%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="编辑记录"><a href="#编辑记录" class="headerlink" title="编辑记录"></a>编辑记录</h1><p>2022-04-21 Bracket Pair Colorizer2</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Bracket-Pair-Colorizer2"><a href="#Bracket-Pair-Colorizer2" class="headerlink" title="Bracket Pair Colorizer2"></a>Bracket Pair Colorizer2</h2><p>今天看FreeSWITCH SDP协商部分的代码，相关处理非常长，导致括号对非常难以记忆。找了下插件发现最火的插件Bracket Pair Colorizer2标记了个废弃，点进主页说明发现扩展已经变成了官方原生特性，因此到配置里面去开启：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/vscode%E6%8B%AC%E5%8F%B7%E8%AE%BE%E7%BD%AE.png" alt="括号配置"></p><p>效果拔群！</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/vscode%E6%8B%AC%E5%8F%B7%E5%BD%A9%E8%89%B2%E6%95%88%E6%9E%9C.png" alt="彩色括号"></p>]]></content>
    
    
    <categories>
      
      <category>存档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>32位应用程序转64位笔记</title>
    <link href="/2022/05/27/32%E4%BD%8D%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BD%AC64%E4%BD%8D%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/27/32%E4%BD%8D%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BD%AC64%E4%BD%8D%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h1><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>最近做一些32位应用程序编译到64位应用的工作，环境是centos 7.9，程序都是用c语言编写，使用gcc编译。</p><h2 id="查看相关信息"><a href="#查看相关信息" class="headerlink" title="查看相关信息"></a>查看相关信息</h2><ul><li>查看gcc版本</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># gcc -v</span><br>Using built-in specs.<br><span class="hljs-attribute">COLLECT_GCC</span>=gcc<br><span class="hljs-attribute">COLLECT_LTO_WRAPPER</span>=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper<br>Target: x86_64-redhat-linux<br>Configured with: <span class="hljs-built_in">..</span>/configure <span class="hljs-attribute">--prefix</span>=/usr <span class="hljs-attribute">--mandir</span>=/usr/share/man <span class="hljs-attribute">--infodir</span>=/usr/share/info <span class="hljs-attribute">--with-bugurl</span>=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared <span class="hljs-attribute">--enable-threads</span>=posix <span class="hljs-attribute">--enable-checking</span>=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id <span class="hljs-attribute">--with-linker-hash-style</span>=gnu <span class="hljs-attribute">--enable-languages</span>=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array --disable-libgcj <span class="hljs-attribute">--with-isl</span>=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install <span class="hljs-attribute">--with-cloog</span>=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function <span class="hljs-attribute">--with-tune</span>=generic <span class="hljs-attribute">--with-arch_32</span>=x86-64 <span class="hljs-attribute">--build</span>=x86_64-redhat-linux<br>Thread model: posix<br>gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) <br></code></pre></td></tr></table></figure><ul><li>查看系统位数</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># uname -a</span><br><span class="hljs-attribute">Linux</span> d5c159febf78 <span class="hljs-number">5</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span>-<span class="hljs-number">109</span>-generic #<span class="hljs-number">123</span>-Ubuntu SMP Fri Apr <span class="hljs-number">8</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">54</span> UTC <span class="hljs-number">2022</span> x86_64 x86_64 x86_64 GNU/Linux<br><span class="hljs-comment"># getconf WORD_BIT</span><br><span class="hljs-attribute">32</span><br><span class="hljs-comment"># getconf LONG_BIT</span><br><span class="hljs-attribute">64</span><br></code></pre></td></tr></table></figure><p>x86_64代表系统是64位的；通过查看WORD_BIT和LONG_BIT也可以判断，32位系统两者均为32，64位系统其值分别为32和64。</p><ul><li><p>查看文件的位数</p><ul><li><p>方法1：file filename</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/%E4%BD%BF%E7%94%A8file%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E4%BD%8D%E6%95%B0.png"></p></li><li><p>方法2：readelf -h filename</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/%E4%BD%BF%E7%94%A8readelf%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E4%BD%8D%E6%95%B0.png"></p></li></ul></li></ul><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>64位的gcc，默认编译64位程序，如果需要编译32位，那么添加<code>-m32</code>即可</p><h2 id="修改原则"><a href="#修改原则" class="headerlink" title="修改原则"></a>修改原则</h2><p>修改参考以下内容，后续从中选择补充到本文</p><p><a href="https://docs.oracle.com/cd/E19205-01/820-1210/bjami/index.html">转换应用程序以适用于 64 位环境</a></p><h2 id="实际修订的内容总结"><a href="#实际修订的内容总结" class="headerlink" title="实际修订的内容总结"></a>实际修订的内容总结</h2><p>本节内容根据实际遇到的问题编写</p><h3 id="va-list"><a href="#va-list" class="headerlink" title="va_list"></a>va_list</h3><h4 id="定义不同"><a href="#定义不同" class="headerlink" title="定义不同"></a>定义不同</h4><p><code>va_list</code>在c里面用于可变参数，在32位应用场景下编译是一个指针，而在64位应用中的实现则是一个结构体。</p><p>因此，在32位程序中可以直接赋值，也可以重复使用va_list变量；但是如果进行64位编译，那么连编译都无法通过。</p><p><code>va_list</code>位于<code>stdarg.h</code></p><p>查看<code>stdarg.h</code>文件:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*===---- stdarg.h - Variable argument handling ----------------------------===</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span><br><span class="hljs-comment"> * See https://llvm.org/LICENSE.txt for license information.</span><br><span class="hljs-comment"> * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *===-----------------------------------------------------------------------===</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __STDARG_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __STDARG_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _VA_LIST</span><br><span class="hljs-keyword">typedef</span> __builtin_va_list va_list;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _VA_LIST</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> va_start(ap, param) __builtin_va_start(ap, param)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> va_end(ap)          __builtin_va_end(ap)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> va_arg(ap, type)    __builtin_va_arg(ap, type)</span><br><br><span class="hljs-comment">/* GCC always defines __va_copy, but does not define va_copy unless in c99 mode</span><br><span class="hljs-comment"> * or -ansi is not specified, since it was not part of C90.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __va_copy(d,s) __builtin_va_copy(d,s)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __STDC_VERSION__ &gt;= 199901L || __cplusplus &gt;= 201103L || !defined(__STRICT_ANSI__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> va_copy(dest, src)  __builtin_va_copy(dest, src)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __GNUC_VA_LIST</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __GNUC_VA_LIST 1</span><br><span class="hljs-keyword">typedef</span> __builtin_va_list __gnuc_va_list;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __STDARG_H */</span></span><br></code></pre></td></tr></table></figure><p>发现定义还是比较简单，__builtin_va_list看起来和平台有关，继续找实现没有找到很具体的。参考别人的博客<a href="https://blog.csdn.net/whatday/article/details/100055076">linux c va_list 32位和64位的差异</a>和自己用gdb看到的数据结构</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">p</span> *stAp<br><span class="hljs-variable">$2</span> = &#123;<span class="hljs-attribute">gp_offset</span> = <span class="hljs-number">48</span>, fp_offset = <span class="hljs-number">48</span>, overflow_arg_area = 0x7fffc73ea210, reg_save_area = 0x7fffc73ea140&#125;<br></code></pre></td></tr></table></figure><p>基本可以确定在32位系统下，<code>va_list</code>的定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//此处只是示意，并非实际定义</span><br><span class="hljs-keyword">typedef</span> va_list <span class="hljs-type">char</span>**;<br></code></pre></td></tr></table></figure><p>在64位系统中，va_list是一个结构体数组，通过数组记录偏移量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 此处只是示意，并非实际定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gp_offset;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fp_offset;<br>    <span class="hljs-type">void</span> * overflow_arg_area;<br>    <span class="hljs-type">void</span> * reg_save_area;<br>&#125; va_list[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><h4 id="用法修改"><a href="#用法修改" class="headerlink" title="用法修改"></a>用法修改</h4><ul><li><p>直接赋值</p><ul><li><p><code>stdarg.h</code>提供了<code>va_copy()</code>接口用于复制<code>va_list</code></p></li><li><p>错误用法(指32位允许,64位不允许)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">va_list bak = p_list;<br></code></pre></td></tr></table></figure></li><li><p>正确的用法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">va_list bak;<br><br>va_copy(bak, p_list);<br><span class="hljs-comment">//use bak do somethine</span><br>va_end(bak);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>重复使用</p><ul><li><p>类似<code>vsnprintf()</code>一类的接口会修改va_list的偏移量。由于在32位系统下<code>va_list</code>是一个指针，因此传入接口的值传递不影响调用方重复使用;但是在64位应用程序当中，传入va_list结构体会使得内部偏移量变化，在重复使用时就会指到错误的内存地址</p></li><li><p>错误用法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">va_list p_list;<br><br>va_start(p_list, fmt);<br><span class="hljs-comment">//重复调用</span><br>vsnprintf(..., p_list);<br>vsnprintf(..., p_list);<br>va_end(p_list);<br></code></pre></td></tr></table></figure></li><li><p>正确用法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">va_list p_list;<br>va_list bak;<br><br>va_start(p_list, fmt);<br><span class="hljs-comment">//重复调用</span><br>va_copy(bak, p_list);<br>vsnprintf(..., p_list);<br>va_end(p_list);<br>vsnprintf(..., bak);<br>va_end(bak);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="32位类型和64位类型的转换"><a href="#32位类型和64位类型的转换" class="headerlink" title="32位类型和64位类型的转换"></a>32位类型和64位类型的转换</h3><p>在32位应用程序当中，int，long，指针均为32位；但是在64位应用程序中，int为32位，long和指针变成了64位。由于位数的变化，部分变量间的转换会出现问题。下面举例一部分不好的地方：</p><h4 id="问题一：用void-指针存储数值"><a href="#问题一：用void-指针存储数值" class="headerlink" title="问题一：用void *指针存储数值"></a>问题一：用void *指针存储数值</h4><p>void *指针不指定类型，在32位应用中有不少图方便直接用其存储数值的使用，在编译成64位时会引发gcc警告。</p><p>解决方案一：数值存储前先转换成intptr_t类型</p><p>解决方案二：非临时变量传给void *其地址</p><h4 id="问题二：用int型直接存储了指针"><a href="#问题二：用int型直接存储了指针" class="headerlink" title="问题二：用int型直接存储了指针"></a>问题二：用int型直接存储了指针</h4><p>由于32位应用int和指针长度一样，可以指针存储指针，有时也做指针用int存储的操作。编译成64位应用时，指针就会被截断导致无效。如果一定要存储用intptr_t存储</p><h4 id="问题三：只是需要布尔值"><a href="#问题三：只是需要布尔值" class="headerlink" title="问题三：只是需要布尔值"></a>问题三：只是需要布尔值</h4><p>代码片段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">__RegResponse(arg1, arg2, (<span class="hljs-type">int</span>) p, p);<br></code></pre></td></tr></table></figure><p>此处第3个参数在函数的实现当中只是做一个布尔值的逻辑判断，此处强转为整形在64位下会引发gcc警告。可以直接使用!!对p指针做两次逻辑运算，自然获得了合法的布尔值，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">__RegResponse(arg1, arg2, !!p, p);<br></code></pre></td></tr></table></figure><h4 id="问题四：位数变化导致隐式强转结果错误"><a href="#问题四：位数变化导致隐式强转结果错误" class="headerlink" title="问题四：位数变化导致隐式强转结果错误"></a>问题四：位数变化导致隐式强转结果错误</h4><p>代码片段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">intptr_t</span> *dst = data + HEAD_ALL_LEN;<br><br>dst[<span class="hljs-number">0</span>] = ntohl(dst[<span class="hljs-number">0</span>]);<br>dst[<span class="hljs-number">1</span>] = ntohl(dst[<span class="hljs-number">1</span>]);<br><br><span class="hljs-keyword">if</span> (dst[<span class="hljs-number">0</span>] == <span class="hljs-number">-1</span>) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>此处intptr_t在32位应用中为有符号32位整数，当编译成64位时，变成了64位有符号整数。而ntohl的返回值是无符号32位整数。</p><p><code>dst[0]</code>中存储的值为网络字节序的 -1, 转换成主机字节序的u32数据时，其值为UINT32_MAX。这个值在强制类型转换为有符号32位整数时，自动就编码成了-1，结果正确；但是在64位应用中，低32位完全可以容纳UINT32_MAX，导致其值不为 -1，使得程序逻辑出现问题。</p><h4 id="问题五：-ld和-lld"><a href="#问题五：-ld和-lld" class="headerlink" title="问题五：%ld和%lld"></a>问题五：<code>%ld</code>和<code>%lld</code></h4><p>使用<code>printf</code>指定格式的时候，64位变量在32位应用要用<code>%lld</code>，但是在64位应用只需要<code>%ld</code>即可。为了解决这种不一致问题，可以使用<code>%&quot;PRId32</code>和<code>%&quot;PRId64</code>代替。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gcc</tag>
      
      <tag>c语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x264学习笔记</title>
    <link href="/2022/04/28/x264%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/28/x264%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h1><p>2022-04-28 第一次编辑</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="H-264"><a href="#H-264" class="headerlink" title="H.264"></a>H.264</h2><h3 id="H-264简介"><a href="#H-264简介" class="headerlink" title="H.264简介"></a>H.264简介</h3><p>H.264是目前最为主流的视频编码标准，同时也是MPEG-4第十部分，一般称为H.264&#x2F;AVC。对比H.264以前广泛使用的视频编码，H.264提供更低的码率和更高的视频质量，同时也提供了更强的容错能力和良好的IP网络适应性。H.264编码在推出之后被视频点播和实时流媒体领域被广泛使用，在标准成立之初，H.264主要提供三个档次的流媒体能力：基本档次(baseline profile)，扩展档次(Extended profile)和主要档次(main profile)；其中，baseline profile被广泛应用于实时流媒体传输，例如视频会议，远程医疗等，提供低码率，低延时，高质量的流媒体视频流。 </p><h3 id="图像质量PSNR"><a href="#图像质量PSNR" class="headerlink" title="图像质量PSNR"></a>图像质量PSNR</h3><p>PSNR即图像峰值信噪比(Peak Signal to Noise Ratio)，作为一种客观的图像质量评价标准，在图像处理相关的工程中被广泛使用，用于评价图像在经过压缩处理之后，获取到的处理图像的质量对比原始图像能否让人满意。其计算公式如下（其中，MSE是原图像与处理图像之间均方误差）：<br>$$<br>PSNR&#x3D;10*log_{10}(\frac {(2^n-1)^2}{MSE})<br>$$<br>作为一种客观图像质量评价方法，对比真实的主观图像质量评测，PSNR仍然存在一定误差。有时PSNR高的图像并不一定能够比PSNR低的图像带来更好的主观图像质量，这是因为人眼对图像质量误差的敏感度并非绝对相同，而是对部分特定场景敏感度更高。H.264基于大量实验数据利用人眼的敏感度进行了大量的优化。</p><h3 id="帧类型和参考帧"><a href="#帧类型和参考帧" class="headerlink" title="帧类型和参考帧"></a>帧类型和参考帧</h3><p>H.264编码中，图像存在不同的帧类型；一般可以分为IDR帧，I帧，P帧，B帧，还有SP&#x2F;SI等帧类型。同时，H.264还会产生SPS、PPS和SEI等NALU单元。下面简单介绍一下主要使用的帧类型(一些扩展类型这里不提)：</p><ol><li>IDR帧 Instantaneous Decoding Refresh 即时解码刷新帧，一定是一个I帧，解码器在接收到IDR帧时，会清空参考帧列表，并重置部分参数。IDR帧后的帧永远不会参考IDR帧前的帧。</li><li>I帧 Intra-coded picture 关键帧，只做帧内预测，只需要当帧画面即可解锁</li><li>P帧 Predictive-coded Picture 前向预测帧，会参考可以之前的参考帧进行帧间预测</li><li>B帧 Bidirectionally predicted picture双向预测帧，会参考前向和后向的参考帧进行帧间预测</li><li>SPS Sequence Parameter Set，序列参数集；包含profile，level，分辨率等重要信息，代表了一组编码序列的全局参数</li><li>PPS Picture Parameter Set，图像参数集，保持了图像编码时所使用的参数</li><li>SEI Supplementary Enhancement Information，图像增强信息，会携带一些自定义信息和对解码可能有帮助的信息</li></ol><h3 id="CABAC和CAVLC"><a href="#CABAC和CAVLC" class="headerlink" title="CABAC和CAVLC"></a>CABAC和CAVLC</h3><p>熵编码的两种方式，熵编码是一种无损压缩的方式。H.264在处理完图像数据之后，通过熵编码进一步提高了编码压缩率。其中CABAC为基于上下文的自适应二进制算数熵编码，CAVLC为基于上下文自适应的可变长编码。实时流媒体传输一般来说baseline profile，只支持CAVLC。</p><h3 id="视频码率控制"><a href="#视频码率控制" class="headerlink" title="视频码率控制"></a>视频码率控制</h3><p>图像是由一个一个的像素点组成，视频则又是由连续的图像组成，因此传输原始的无损图片会占用极大的带宽。视频编码的主要目的就在于，通过有损的压缩，在保证图像质量的同时尽可能的降低视频传输时占用的带宽，即视频码率。显然，视频的质量越高，视频的码率必然越高，进行码率控制，就是要求视频编码在质量和码率直接达到一定平衡。</p><h4 id="CBR-VS-VBR"><a href="#CBR-VS-VBR" class="headerlink" title="CBR VS VBR"></a>CBR VS VBR</h4><p>CBR即恒定码率控制(Constant Bitrate)，指定一个比特率，每一帧图像都按照这个比特数进行编码。这种编码方式在音频编码中非常常见，但是在视频编码领域，由于H.264当中不同帧类型要求的比特数本来就不同，同时不同的场景对于比特数的需求也不相同，复杂的场景显然需要更多的比特数，而简单固定的场景并不需要很多的比特数进行编码。导致固定码率，意味着对复杂的场景可能出现画质很差，对简单恒定的场景出现大量的比特浪费。</p><p>为了修正CBR存在的问题，视频编码就出现了VBR的码率控制方法，即可变码率控制(Variable Bitrate)，用于在给定比特限制下保持图像的最高质量。简单来说，VBR的核心思想在于，对于复杂的难编码的场景给予更多的比特，对于简单的易于编码的场景使用更少的比特，从而达成始终以较少的比特保持一定的图像质量。</p><p>可变比特率类型的码率控制方式在视频码率控制当中是主流方式。</p><h4 id="编码应用场景"><a href="#编码应用场景" class="headerlink" title="编码应用场景"></a>编码应用场景</h4><p>可变码率控制方式，对于不同的场景给予不同的比特数；同时，实际使用视频的场景也对视频的码率具有影响。不同的profile之间，由于启用的压缩技术不同，码率差距和编码速度也有区别。对于视频应用来说，一般有如下几种应用场景：</p><ol><li>视频存档：单纯的保存视频，不关心编码速度，最重要的指标是视频质量和视频大小，可以预知场景</li><li>流媒体点播：通过网络传输视频，不关心编码速度，在保证视频质量的时候视频码率不能超过带宽，尽量不占用带宽，可以预知场景</li><li>流媒体直播：通过网络传输实时视频，要求编码速度快，码率不超过带宽的情况下尽可能低，同时保证视频质量，不能预知场景</li><li>面向特定存储介质：将媒体刻录到DVD等介质上，要求编码出的视频大小刚好占满介质容量，并且质量高，可以预知场景</li></ol><p>不同的编码场景对视频指标的关注点不尽相同，其中流媒体直播即实时流媒体传输，对视频编码的要求更高。在实时流媒体传输当中，最重要的是保持流媒体的实时性，因此一般只采用baseline profile。同时，实时流媒体传输同样关注视频码率和视频质量，要求在码率足够小的同时质量足够好。并且，不能预知场景使得实时流媒体传输难以根据特定场景应用场景的优化参数。</p><h4 id="QP"><a href="#QP" class="headerlink" title="QP"></a>QP</h4><p>量化参数（Quantization Parameter,QP）控制着压缩大小。QP越大压缩率越高同时质量越低，QP越小压缩率越低同时质量越高。在H.264中，QP的范围是0-51间的整数。一般而言，控制码率就是控制编码的比特数，也即控制编码的QP值</p><p>TODO <a href="https://www.vcodex.com/h264avc-4x4-transform-and-quantization/">QP的原理</a></p><h4 id="码率控制方式"><a href="#码率控制方式" class="headerlink" title="码率控制方式"></a>码率控制方式</h4><h5 id="CQP"><a href="#CQP" class="headerlink" title="CQP"></a>CQP</h5><p>恒定QP值（Constant QP）是通过保证每帧画面QP值固定进行码率控制的方法，可以发现，通过恒定QP完全无法控制码率，每帧画面编码出的大小完全受限于画面复杂度。因此，在x264文档中只推荐启用CQP用于研究，而不推荐使用CQP控制码率。</p><h5 id="ABR"><a href="#ABR" class="headerlink" title="ABR"></a>ABR</h5><p>平均码率控制模式(Average Bitrate)是通过控制整个码流的平均码率，从而控制码率的模式。ABR并不要求整个视频码率恒定，但是面对突发的过高码率，ABR会压低后续画面的码率以保持平均码率。因此，ABR虽然简单，但是由于在大部分场景中，编码器无法知道接下来的编码帧需要多大的码率，从而导致在画面变化时画面质量波动十分剧烈，使得视频质量低于预期。因此，在大多数情况都不应该使用ABR模式。</p><h5 id="2-PASS-ABR"><a href="#2-PASS-ABR" class="headerlink" title="2-PASS ABR"></a>2-PASS ABR</h5><p>ABR模式因为很难预测下一帧画面的消耗，往往导致码率控制效果很差。但是，如果允许编码器进行多次编码，编码器在第二次及之后的编码过程中就可以提前知道每一帧编码的消耗，从而更好的分配比特，这就是2-PASS ABR控制方式。在第一次编码时，编码器首先获得了视频编码的消耗，从而在第二次编码时更合理的分配，一般而言第二次编码会应用ABR码率控制，第一次编码CQP即可。</p><p>2-PASS编码能够在给定码率下达到较好质量，但是仍然存在一些问题。首先，如果给定的码率不足以保证图像质量，画面质量还是会低于预期，为了获得最好质量必须要有一个经验性的码率（需要多次实验）；其次，2-PASS码率控制进行两次编码，这对于实时流媒体来说基本是无法忍受的；最后，码率波动同样无法避免，如果瞬时码率过高，流媒体客户端的接受能力就必须纳入考虑。</p><h5 id="CRF"><a href="#CRF" class="headerlink" title="CRF"></a>CRF</h5><p>恒定视频质量( Constant Rate Factor)通过指定crf值，使编码器试图保证输出的图像质量恒定。crf值是一个类似于QP的概念，8bit的H.264编码的crf值理论范围是[0,51]，在x264中，默认的crf值为23。crf值每增长6，输出的视频码率就变为原来的1&#x2F;2，crf值和视频码率满足对数关系。在理论上，crf &#x3D; 0 即完全无损压缩，crf &#x3D; 51 即最大程度的压缩。在实际实践中，一般认为crf &#x3D; 18 即为H.264的无损画面，因此在主观图像质量评价中，crf值一般使用[18,28]作为范围，有时也会应用到17,29等边界值用于极端情况。</p><p>使用CRF进行码率控制，可以达到比较优质的图像质量，但是类似于CQP，CRF并不能对码率做出很好的保证。</p><h5 id="VBV"><a href="#VBV" class="headerlink" title="VBV"></a>VBV</h5><p>视频缓存验证(Video Buffering Verifier)通过设定视频流的码率上界和码率下界，保证媒体流既不会高于某个特定码率，也不会低于某个特定码率，从而完成码率的控制。使用VBV需要设置编码器的buffsize，一般设置为码率上界的两倍。</p><p>VBV的特性保证了在实时流媒体传输中，视频编码的码率总是被约束在接受方的能力范围内，因此在实时流媒体传输中被普遍使用，同时VBV实际上与2-PASS和CRF等控制方式兼容，因此可以做到结合使用。</p><h5 id="CRF-VBV"><a href="#CRF-VBV" class="headerlink" title="CRF + VBV"></a>CRF + VBV</h5><p>由于CRF和VBV完全兼容，因此可以同时启用这两个策略，在一定码率下保证画面的画质。</p><h4 id="各个码率控制方式对比总结"><a href="#各个码率控制方式对比总结" class="headerlink" title="各个码率控制方式对比总结"></a>各个码率控制方式对比总结</h4><table><thead><tr><th>控制方式</th><th>应用面</th><th>不适合的场景</th></tr></thead><tbody><tr><td>CQP</td><td>可以用于研究</td><td>几乎所有实际落地场景</td></tr><tr><td>ABR</td><td>要求简单快速</td><td>除非必须极低延时，几乎所有场景不应该使用</td></tr><tr><td>2-PASS ABR</td><td>面向特定场景，非实时的处理</td><td>要求低延时的场景，快速编码场景</td></tr><tr><td>CRF</td><td>对图像质量有要求的场景</td><td>对码率波动十分敏感的场景</td></tr><tr><td>VBV</td><td>实时流媒体，带宽受限的流媒体</td><td>存档类的编码</td></tr><tr><td>CRF + VBV</td><td>实时流媒体，带宽受限的流媒体</td><td>存档类的编码</td></tr></tbody></table><p>参考文档  <a href="https://mailman.videolan.org/pipermail/x264-devel/2010-February/006934.html">[x264-devel] Making sense out of x264 rate control methods</a></p><h2 id="x264"><a href="#x264" class="headerlink" title="x264"></a>x264</h2><h3 id="x264代码框架"><a href="#x264代码框架" class="headerlink" title="x264代码框架"></a>x264代码框架</h3><p>文件组织如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sh"> &gt; tree -L 1<br>.<br>├── AUTHORS<br>├── autocomplete.c<br>├── common //通用代码<br>├── config.guess<br>├── config.h<br>├── config.log<br>├── config.mak<br>├── config.sub<br>├── configure<br>├── COPYING<br>├── doc //文档<br>├── encoder //编码器代码<br>├── example.c //示例<br>├── extras <br>├── filters<br>├── input<br>├── Makefile<br>├── output //输出格式<br>├── tools<br>├── version.sh<br>├── x264.c<br>├── x264cli.h<br>├── x264_config.h<br>├── x264dll.c<br>├── x264.h<br>├── x264.pc<br>├── x264res.manifest<br>└── x264res.rc<br></code></pre></td></tr></table></figure><p>完整树如下（删减了git相关的文件）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><code class="hljs sh">&gt; tree -a<br>.<br>├── AUTHORS<br>├── autocomplete.c<br>├── common<br>│   ├── aarch64<br>│   │   ├── asm-offsets.c<br>│   │   ├── asm-offsets.h<br>│   │   ├── asm.S<br>│   │   ├── bitstream-a.S<br>│   │   ├── bitstream.h<br>│   │   ├── cabac-a.S<br>│   │   ├── dct-a.S<br>│   │   ├── dct.h<br>│   │   ├── deblock-a.S<br>│   │   ├── deblock.h<br>│   │   ├── mc-a.S<br>│   │   ├── mc-c.c<br>│   │   ├── mc.h<br>│   │   ├── pixel-a.S<br>│   │   ├── pixel.h<br>│   │   ├── predict-a.S<br>│   │   ├── predict-c.c<br>│   │   ├── predict.h<br>│   │   ├── quant-a.S<br>│   │   └── quant.h<br>│   ├── arm<br>│   │   ├── asm.S<br>│   │   ├── bitstream-a.S<br>│   │   ├── bitstream.h<br>│   │   ├── cpu-a.S<br>│   │   ├── dct-a.S<br>│   │   ├── dct.h<br>│   │   ├── deblock-a.S<br>│   │   ├── deblock.h<br>│   │   ├── mc-a.S<br>│   │   ├── mc-c.c<br>│   │   ├── mc.h<br>│   │   ├── pixel-a.S<br>│   │   ├── pixel.h<br>│   │   ├── predict-a.S<br>│   │   ├── predict-c.c<br>│   │   ├── predict.h<br>│   │   ├── quant-a.S<br>│   │   └── quant.h<br>│   ├── base.c<br>│   ├── base.h<br>│   ├── bitstream.c<br>│   ├── bitstream.h<br>│   ├── cabac.c<br>│   ├── cabac.h<br>│   ├── common.c<br>│   ├── common.h<br>│   ├── cpu.c<br>│   ├── cpu.h<br>│   ├── dct.c<br>│   ├── dct.h<br>│   ├── deblock.c<br>│   ├── frame.c<br>│   ├── frame.h<br>│   ├── macroblock.c<br>│   ├── macroblock.h<br>│   ├── mc.c<br>│   ├── mc.h<br>│   ├── mips<br>│   │   ├── dct-c.c<br>│   │   ├── dct.h<br>│   │   ├── deblock-c.c<br>│   │   ├── deblock.h<br>│   │   ├── macros.h<br>│   │   ├── mc-c.c<br>│   │   ├── mc.h<br>│   │   ├── pixel-c.c<br>│   │   ├── pixel.h<br>│   │   ├── predict-c.c<br>│   │   ├── predict.h<br>│   │   ├── quant-c.c<br>│   │   └── quant.h<br>│   ├── mvpred.c<br>│   ├── opencl<br>│   │   ├── bidir.cl<br>│   │   ├── downscale.cl<br>│   │   ├── intra.cl<br>│   │   ├── motionsearch.cl<br>│   │   ├── subpel.cl<br>│   │   ├── weightp.cl<br>│   │   └── x264-cl.h<br>│   ├── opencl.c<br>│   ├── opencl.h<br>│   ├── osdep.c<br>│   ├── osdep.h<br>│   ├── pixel.c<br>│   ├── pixel.h<br>│   ├── ppc<br>│   │   ├── dct.c<br>│   │   ├── dct.h<br>│   │   ├── deblock.c<br>│   │   ├── deblock.h<br>│   │   ├── mc.c<br>│   │   ├── mc.h<br>│   │   ├── pixel.c<br>│   │   ├── pixel.h<br>│   │   ├── ppccommon.h<br>│   │   ├── predict.c<br>│   │   ├── predict.h<br>│   │   ├── quant.c<br>│   │   └── quant.h<br>│   ├── predict.c<br>│   ├── predict.h<br>│   ├── quant.c<br>│   ├── quant.h<br>│   ├── rectangle.c<br>│   ├── rectangle.h<br>│   ├── set.c<br>│   ├── set.h<br>│   ├── tables.c<br>│   ├── tables.h<br>│   ├── threadpool.c<br>│   ├── threadpool.h<br>│   ├── vlc.c<br>│   ├── win32thread.c<br>│   ├── win32thread.h<br>│   └── x86<br>│       ├── bitstream-a.asm<br>│       ├── bitstream.h<br>│       ├── cabac-a.asm<br>│       ├── const-a.asm<br>│       ├── cpu-a.asm<br>│       ├── dct-32.asm<br>│       ├── dct-64.asm<br>│       ├── dct-a.asm<br>│       ├── dct.h<br>│       ├── deblock-a.asm<br>│       ├── deblock.h<br>│       ├── mc-a2.asm<br>│       ├── mc-a.asm<br>│       ├── mc-c.c<br>│       ├── mc.h<br>│       ├── pixel-32.asm<br>│       ├── pixel-a.asm<br>│       ├── pixel.h<br>│       ├── predict-a.asm<br>│       ├── predict-c.c<br>│       ├── predict.h<br>│       ├── quant-a.asm<br>│       ├── quant.h<br>│       ├── sad16-a.asm<br>│       ├── sad-a.asm<br>│       ├── trellis-64.asm<br>│       ├── util.h<br>│       ├── x86inc.asm<br>│       └── x86util.asm<br>├── config.guess<br>├── config.h<br>├── config.log<br>├── config.mak<br>├── config.sub<br>├── configure<br>├── COPYING<br>├── doc<br>│   ├── ratecontrol.txt<br>│   ├── regression_test.txt<br>│   ├── standards.txt<br>│   ├── threads.txt<br>│   └── vui.txt<br>├── encoder<br>│   ├── analyse.c<br>│   ├── analyse.h<br>│   ├── api.c<br>│   ├── cabac.c<br>│   ├── cavlc.c<br>│   ├── encoder.c<br>│   ├── lookahead.c<br>│   ├── macroblock.c<br>│   ├── macroblock.h<br>│   ├── me.c<br>│   ├── me.h<br>│   ├── ratecontrol.c<br>│   ├── ratecontrol.h<br>│   ├── rdo.c<br>│   ├── set.c<br>│   ├── set.h<br>│   ├── slicetype.c<br>│   ├── slicetype-cl.c<br>│   └── slicetype-cl.h<br>├── example.c<br>├── extras<br>│   ├── avisynth_c.h<br>│   ├── avxsynth_c.h<br>│   ├── cl.h<br>│   ├── cl_platform.h<br>│   ├── getopt.c<br>│   ├── getopt.h<br>│   ├── intel_dispatcher.h<br>│   ├── inttypes.h<br>│   └── stdint.h<br>├── filters<br>│   ├── filters.c<br>│   ├── filters.h<br>│   └── video<br>│       ├── cache.c<br>│       ├── crop.c<br>│       ├── depth.c<br>│       ├── fix_vfr_pts.c<br>│       ├── internal.c<br>│       ├── internal.h<br>│       ├── resize.c<br>│       ├── select_every.c<br>│       ├── source.c<br>│       ├── video.c<br>│       └── video.h<br>├── input<br>│   ├── avs.c<br>│   ├── ffms.c<br>│   ├── input.c<br>│   ├── input.h<br>│   ├── lavf.c<br>│   ├── raw.c<br>│   ├── thread.c<br>│   ├── timecode.c<br>│   └── y4m.c<br>├── Makefile<br>├── output<br>│   ├── flv_bytestream.c<br>│   ├── flv_bytestream.h<br>│   ├── flv.c<br>│   ├── matroska.c<br>│   ├── matroska_ebml.c<br>│   ├── matroska_ebml.h<br>│   ├── mp4.c<br>│   ├── mp4_lsmash.c<br>│   ├── output.h<br>│   └── raw.c<br>├── tools<br>│   ├── bash-autocomplete.sh<br>│   ├── checkasm-aarch64.S<br>│   ├── checkasm-a.asm<br>│   ├── checkasm-arm.S<br>│   ├── checkasm.c<br>│   ├── cltostr.sh<br>│   ├── countquant_x264.pl<br>│   ├── digress<br>│   │   ├── cli.py<br>│   │   ├── comparers.py<br>│   │   ├── constants.py<br>│   │   ├── errors.py<br>│   │   ├── __init__.py<br>│   │   ├── scm<br>│   │   │   ├── dummy.py<br>│   │   │   ├── git.py<br>│   │   │   └── __init__.py<br>│   │   └── testing.py<br>│   ├── gas-preprocessor.pl<br>│   ├── msvsdepend.sh<br>│   ├── q_matrix_jvt.cfg<br>│   └── test_x264.py<br>├── version.sh<br>├── x264.c <br>├── x264cli.h<br>├── x264_config.h<br>├── x264dll.c<br>├── x264.h<br>├── x264.pc<br>├── x264res.manifest<br>└── x264res.rc<br></code></pre></td></tr></table></figure><h4 id="代码框架分析"><a href="#代码框架分析" class="headerlink" title="代码框架分析"></a>代码框架分析</h4><p>TODO</p><h3 id="x264代码分析"><a href="#x264代码分析" class="headerlink" title="x264代码分析"></a>x264代码分析</h3><p>在编译完成之后，x264分为可执行程序x264和库libx264。先从可执行程序x264看起，了解大概流程。</p><h4 id="整体调用分析"><a href="#整体调用分析" class="headerlink" title="整体调用分析"></a>整体调用分析</h4><div align = "center">    <text>x264调用流程</text>    <img src = "https://nyamori.oss-cn-shanghai.aliyuncs.com/img/x264调用流程.png" width = "100%" height = "100%"  style="border:0;box-shadow: none;">    </img></div> <p>注：图中橙色函数为实际调用需要的x264 API，红色函数为目前认为和码率控制有关的函数，绿色为注释</p><h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><p>x264.c中定义了x264的main函数，这个函数处理命令行参数，设置信号；然后进行编码处理和完成后的清理工作。在该函数中，主要的核心函数为prase()和encode()，核心结构体为x264_param_t和cli_opt_t，如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">REALIGN_STACK <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>( argc == <span class="hljs-number">4</span> &amp;&amp; !<span class="hljs-built_in">strcmp</span>( argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;--autocomplete&quot;</span> ) )<br>        <span class="hljs-keyword">return</span> x264_cli_autocomplete( argv[<span class="hljs-number">2</span>], argv[<span class="hljs-number">3</span>] );<br><br>    <span class="hljs-type">x264_param_t</span> param; <span class="hljs-comment">//x264对外提供的参数，定义在x264.h中</span><br>    <span class="hljs-type">cli_opt_t</span> opt = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//cli参数，定义在x264.c中</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>    FAIL_IF_ERROR( x264_threading_init(), <span class="hljs-string">&quot;unable to initialize threading\n&quot;</span> );<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN32</span><br>    FAIL_IF_ERROR( !get_argv_utf8( &amp;argc, &amp;argv ), <span class="hljs-string">&quot;unable to convert command line to UTF-8\n&quot;</span> );<br><br>    GetConsoleTitleW( org_console_title, CONSOLE_TITLE_SIZE );<br>    _setmode( _fileno( <span class="hljs-built_in">stdin</span> ),  _O_BINARY );<br>    _setmode( _fileno( <span class="hljs-built_in">stdout</span> ), _O_BINARY );<br>    _setmode( _fileno( <span class="hljs-built_in">stderr</span> ), _O_BINARY );<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 此处对命令行参数进行解析，初始化x264参数</span><br>    x264_param_default( &amp;param );<br>    <span class="hljs-comment">/* Parse command line */</span><br>    <span class="hljs-keyword">if</span>( parse( argc, argv, &amp;param, &amp;opt ) &lt; <span class="hljs-number">0</span> )<br>        ret = <span class="hljs-number">-1</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN32</span><br>    <span class="hljs-comment">/* Restore title; it can be changed by input modules */</span><br>    SetConsoleTitleW( org_console_title );<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* Control-C handler */</span><br>    signal( SIGINT, sigint_handler );<br><br>    <span class="hljs-comment">//编码操作</span><br>    <span class="hljs-keyword">if</span>( !ret )<br>        ret = encode( &amp;param, &amp;opt );<br><br>    <span class="hljs-comment">/* clean up handles */</span><br>    <span class="hljs-keyword">if</span>( filter.<span class="hljs-built_in">free</span> )<br>        filter.<span class="hljs-built_in">free</span>( opt.hin );<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( opt.hin )<br>        cli_input.close_file( opt.hin );<br>    <span class="hljs-keyword">if</span>( opt.hout )<br>        cli_output.close_file( opt.hout, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> );<br>    <span class="hljs-keyword">if</span>( opt.tcfile_out )<br>        fclose( opt.tcfile_out );<br>    <span class="hljs-keyword">if</span>( opt.qpfile )<br>        fclose( opt.qpfile );<br>    x264_param_cleanup( &amp;param );<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN32</span><br>    SetConsoleTitleW( org_console_title );<br>    <span class="hljs-built_in">free</span>( argv );<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续分析两个关键函数</p><h4 id="parse-argc-argv-amp-param-amp-opt"><a href="#parse-argc-argv-amp-param-amp-opt" class="headerlink" title="parse( argc, argv, &amp;param, &amp;opt )"></a>parse( argc, argv, &amp;param, &amp;opt )</h4><p>prase函数用于解析命令行参数，并对x264_param_t进行初始化。prase主要调用了以下函数(位于common&#x2F;base.c)进行设置设置：</p><ol><li>x264_param_default_preset - 根据preset和tune设置参数</li><li>x264_param_default - 设置默认参数</li><li>x264_param_parse - 解析用户自带的参数</li><li>x264_param_apply_profile - 设置profile</li></ol><h5 id="x264-param-default-common-x2F-base-c"><a href="#x264-param-default-common-x2F-base-c" class="headerlink" title="x264_param_default(common&#x2F;base.c)"></a>x264_param_default(common&#x2F;base.c)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/****************************************************************************</span><br><span class="hljs-comment"> * x264_param_default:初始化默认参数，因此会设置全部参数的默认值</span><br><span class="hljs-comment"> ****************************************************************************/</span><br>REALIGN_STACK <span class="hljs-type">void</span> <span class="hljs-title function_">x264_param_default</span><span class="hljs-params">( <span class="hljs-type">x264_param_t</span> *param )</span><br>&#123;<br>    <span class="hljs-built_in">memset</span>( param, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>( <span class="hljs-type">x264_param_t</span> ) );<br><br>    <span class="hljs-comment">/* CPU autodetect */</span><br>    param-&gt;cpu = x264_cpu_detect();<br>    param-&gt;i_threads = X264_THREADS_AUTO;<br>    param-&gt;i_lookahead_threads = X264_THREADS_AUTO;<br>    param-&gt;b_deterministic = <span class="hljs-number">1</span>;<br>    param-&gt;i_sync_lookahead = X264_SYNC_LOOKAHEAD_AUTO;<br><br>    <span class="hljs-comment">/* Video properties */</span><br>    param-&gt;i_csp           = X264_CHROMA_FORMAT ? X264_CHROMA_FORMAT : X264_CSP_I420;<br>    param-&gt;i_width         = <span class="hljs-number">0</span>;<br>    param-&gt;i_height        = <span class="hljs-number">0</span>;<br>    param-&gt;vui.i_sar_width = <span class="hljs-number">0</span>;<br>    param-&gt;vui.i_sar_height= <span class="hljs-number">0</span>;<br>    param-&gt;vui.i_overscan  = <span class="hljs-number">0</span>;  <span class="hljs-comment">/* undef */</span><br>    param-&gt;vui.i_vidformat = <span class="hljs-number">5</span>;  <span class="hljs-comment">/* undef */</span><br>    param-&gt;vui.b_fullrange = <span class="hljs-number">-1</span>; <span class="hljs-comment">/* default depends on input */</span><br>    param-&gt;vui.i_colorprim = <span class="hljs-number">2</span>;  <span class="hljs-comment">/* undef */</span><br>    param-&gt;vui.i_transfer  = <span class="hljs-number">2</span>;  <span class="hljs-comment">/* undef */</span><br>    param-&gt;vui.i_colmatrix = <span class="hljs-number">-1</span>; <span class="hljs-comment">/* default depends on input */</span><br>    param-&gt;vui.i_chroma_loc= <span class="hljs-number">0</span>;  <span class="hljs-comment">/* left center */</span><br>    param-&gt;i_fps_num       = <span class="hljs-number">25</span>;<br>    param-&gt;i_fps_den       = <span class="hljs-number">1</span>;<br>    param-&gt;i_level_idc     = <span class="hljs-number">-1</span>;<br>    param-&gt;i_slice_max_size = <span class="hljs-number">0</span>;<br>    param-&gt;i_slice_max_mbs = <span class="hljs-number">0</span>;<br>    param-&gt;i_slice_count = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> HAVE_BITDEPTH8</span><br>    param-&gt;i_bitdepth = <span class="hljs-number">8</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> HAVE_BITDEPTH10</span><br>    param-&gt;i_bitdepth = <span class="hljs-number">10</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    param-&gt;i_bitdepth = <span class="hljs-number">8</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* Encoder parameters */</span><br>    param-&gt;i_frame_reference = <span class="hljs-number">3</span>;<br>    param-&gt;i_keyint_max = <span class="hljs-number">250</span>;<br>    param-&gt;i_keyint_min = X264_KEYINT_MIN_AUTO;<br>    param-&gt;i_bframe = <span class="hljs-number">3</span>;<br>    param-&gt;i_scenecut_threshold = <span class="hljs-number">40</span>;<br>    param-&gt;i_bframe_adaptive = X264_B_ADAPT_FAST;<br>    param-&gt;i_bframe_bias = <span class="hljs-number">0</span>;<br>    param-&gt;i_bframe_pyramid = X264_B_PYRAMID_NORMAL;<br>    param-&gt;b_interlaced = <span class="hljs-number">0</span>;<br>    param-&gt;b_constrained_intra = <span class="hljs-number">0</span>;<br><br>    param-&gt;b_deblocking_filter = <span class="hljs-number">1</span>;<br>    param-&gt;i_deblocking_filter_alphac0 = <span class="hljs-number">0</span>;<br>    param-&gt;i_deblocking_filter_beta = <span class="hljs-number">0</span>;<br><br>    param-&gt;b_cabac = <span class="hljs-number">1</span>;<br>    param-&gt;i_cabac_init_idc = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//以下为码率控制参数</span><br>    param-&gt;rc.i_rc_method = X264_RC_CRF;<span class="hljs-comment">//默认crf</span><br>    param-&gt;rc.i_bitrate = <span class="hljs-number">0</span>;<br>    param-&gt;rc.f_rate_tolerance = <span class="hljs-number">1.0</span>;<br>    param-&gt;rc.i_vbv_max_bitrate = <span class="hljs-number">0</span>;<br>    param-&gt;rc.i_vbv_buffer_size = <span class="hljs-number">0</span>;<br>    param-&gt;rc.f_vbv_buffer_init = <span class="hljs-number">0.9</span>;<br>    param-&gt;rc.i_qp_constant = <span class="hljs-number">-1</span>;<br>    param-&gt;rc.f_rf_constant = <span class="hljs-number">23</span>;<br>    param-&gt;rc.i_qp_min = <span class="hljs-number">0</span>;<br>    param-&gt;rc.i_qp_max = INT_MAX;<br>    param-&gt;rc.i_qp_step = <span class="hljs-number">4</span>;<br>    param-&gt;rc.f_ip_factor = <span class="hljs-number">1.4</span>;<br>    param-&gt;rc.f_pb_factor = <span class="hljs-number">1.3</span>;<br>    param-&gt;rc.i_aq_mode = X264_AQ_VARIANCE;<br>    param-&gt;rc.f_aq_strength = <span class="hljs-number">1.0</span>;<br>    param-&gt;rc.i_lookahead = <span class="hljs-number">40</span>;<br><br>    param-&gt;rc.b_stat_write = <span class="hljs-number">0</span>;<br>    param-&gt;rc.psz_stat_out = <span class="hljs-string">&quot;x264_2pass.log&quot;</span>;<br>    param-&gt;rc.b_stat_read = <span class="hljs-number">0</span>;<br>    param-&gt;rc.psz_stat_in = <span class="hljs-string">&quot;x264_2pass.log&quot;</span>;<br>    param-&gt;rc.f_qcompress = <span class="hljs-number">0.6</span>;<br>    param-&gt;rc.f_qblur = <span class="hljs-number">0.5</span>;<br>    param-&gt;rc.f_complexity_blur = <span class="hljs-number">20</span>;<br>    param-&gt;rc.i_zones = <span class="hljs-number">0</span>;<br>    param-&gt;rc.b_mb_tree = <span class="hljs-number">1</span>;<br>   <br>    <span class="hljs-comment">/* Log */</span><br>    param-&gt;pf_log = x264_log_default;<br>    param-&gt;p_log_private = <span class="hljs-literal">NULL</span>;<br>    param-&gt;i_log_level = X264_LOG_INFO;<br><br>    <span class="hljs-comment">/*analysis相关 */</span><br>    param-&gt;analyse.intra = X264_ANALYSE_I4x4 | X264_ANALYSE_I8x8;<br>    param-&gt;analyse.inter = X264_ANALYSE_I4x4 | X264_ANALYSE_I8x8<br>                         | X264_ANALYSE_PSUB16x16 | X264_ANALYSE_BSUB16x16;<br>    param-&gt;analyse.i_direct_mv_pred = X264_DIRECT_PRED_SPATIAL;<br>    param-&gt;analyse.i_me_method = X264_ME_HEX; <span class="hljs-comment">//六边形搜索</span><br>    param-&gt;analyse.f_psy_rd = <span class="hljs-number">1.0</span>;<br>    param-&gt;analyse.b_psy = <span class="hljs-number">1</span>;<br>    param-&gt;analyse.f_psy_trellis = <span class="hljs-number">0</span>;<br>    param-&gt;analyse.i_me_range = <span class="hljs-number">16</span>;<br>    param-&gt;analyse.i_subpel_refine = <span class="hljs-number">7</span>;<br>    param-&gt;analyse.b_mixed_references = <span class="hljs-number">1</span>;<br>    param-&gt;analyse.b_chroma_me = <span class="hljs-number">1</span>;<br>    param-&gt;analyse.i_mv_range_thread = <span class="hljs-number">-1</span>;<br>    param-&gt;analyse.i_mv_range = <span class="hljs-number">-1</span>; <span class="hljs-comment">// set from level_idc</span><br>    param-&gt;analyse.i_chroma_qp_offset = <span class="hljs-number">0</span>;<br>    param-&gt;analyse.b_fast_pskip = <span class="hljs-number">1</span>;<br>    param-&gt;analyse.b_weighted_bipred = <span class="hljs-number">1</span>;<br>    param-&gt;analyse.i_weighted_pred = X264_WEIGHTP_SMART;<br>    param-&gt;analyse.b_dct_decimate = <span class="hljs-number">1</span>;<br>    param-&gt;analyse.b_transform_8x8 = <span class="hljs-number">1</span>;<br>    param-&gt;analyse.i_trellis = <span class="hljs-number">1</span>;<br>    param-&gt;analyse.i_luma_deadzone[<span class="hljs-number">0</span>] = <span class="hljs-number">21</span>;<br>    param-&gt;analyse.i_luma_deadzone[<span class="hljs-number">1</span>] = <span class="hljs-number">11</span>;<br>    param-&gt;analyse.b_psnr = <span class="hljs-number">0</span>;<br>    param-&gt;analyse.b_ssim = <span class="hljs-number">0</span>;<br><br>    param-&gt;i_cqm_preset = X264_CQM_FLAT;<br>    <span class="hljs-built_in">memset</span>( param-&gt;cqm_4iy, <span class="hljs-number">16</span>, <span class="hljs-keyword">sizeof</span>( param-&gt;cqm_4iy ) );<br>    <span class="hljs-built_in">memset</span>( param-&gt;cqm_4py, <span class="hljs-number">16</span>, <span class="hljs-keyword">sizeof</span>( param-&gt;cqm_4py ) );<br>    <span class="hljs-built_in">memset</span>( param-&gt;cqm_4ic, <span class="hljs-number">16</span>, <span class="hljs-keyword">sizeof</span>( param-&gt;cqm_4ic ) );<br>    <span class="hljs-built_in">memset</span>( param-&gt;cqm_4pc, <span class="hljs-number">16</span>, <span class="hljs-keyword">sizeof</span>( param-&gt;cqm_4pc ) );<br>    <span class="hljs-built_in">memset</span>( param-&gt;cqm_8iy, <span class="hljs-number">16</span>, <span class="hljs-keyword">sizeof</span>( param-&gt;cqm_8iy ) );<br>    <span class="hljs-built_in">memset</span>( param-&gt;cqm_8py, <span class="hljs-number">16</span>, <span class="hljs-keyword">sizeof</span>( param-&gt;cqm_8py ) );<br>    <span class="hljs-built_in">memset</span>( param-&gt;cqm_8ic, <span class="hljs-number">16</span>, <span class="hljs-keyword">sizeof</span>( param-&gt;cqm_8ic ) );<br>    <span class="hljs-built_in">memset</span>( param-&gt;cqm_8pc, <span class="hljs-number">16</span>, <span class="hljs-keyword">sizeof</span>( param-&gt;cqm_8pc ) );<br><br>    param-&gt;b_repeat_headers = <span class="hljs-number">1</span>;<br>    param-&gt;b_annexb = <span class="hljs-number">1</span>;<br>    param-&gt;b_aud = <span class="hljs-number">0</span>;<br>    param-&gt;b_vfr_input = <span class="hljs-number">1</span>;<br>    param-&gt;i_nal_hrd = X264_NAL_HRD_NONE;<br>    param-&gt;b_tff = <span class="hljs-number">1</span>;<br>    param-&gt;b_pic_struct = <span class="hljs-number">0</span>;<br>    param-&gt;b_fake_interlaced = <span class="hljs-number">0</span>;<br>    param-&gt;i_frame_packing = <span class="hljs-number">-1</span>;<br>    param-&gt;i_alternative_transfer = <span class="hljs-number">2</span>; <span class="hljs-comment">/* undef */</span><br>    param-&gt;b_opencl = <span class="hljs-number">0</span>;<br>    param-&gt;i_opencl_device = <span class="hljs-number">0</span>;<br>    param-&gt;opencl_device_id = <span class="hljs-literal">NULL</span>;<br>    param-&gt;psz_clbin_file = <span class="hljs-literal">NULL</span>;<br>    param-&gt;i_avcintra_class = <span class="hljs-number">0</span>;<br>    param-&gt;i_avcintra_flavor = X264_AVCINTRA_FLAVOR_PANASONIC;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="x264-param-default-preset-common-x2F-base-c"><a href="#x264-param-default-preset-common-x2F-base-c" class="headerlink" title="x264_param_default_preset(common&#x2F;base.c)"></a>x264_param_default_preset(common&#x2F;base.c)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//设置x264默认的preset和tune</span><br>REALIGN_STACK <span class="hljs-type">int</span> <span class="hljs-title function_">x264_param_default_preset</span><span class="hljs-params">( <span class="hljs-type">x264_param_t</span> *param, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *preset, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *tune )</span><br>&#123;<br>    <span class="hljs-comment">//这里又一次把参数设置到了默认值</span><br>    x264_param_default( param );<br><br>    <span class="hljs-keyword">if</span>( preset &amp;&amp; param_apply_preset( param, preset ) &lt; <span class="hljs-number">0</span> )<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>( tune &amp;&amp; param_apply_tune( param, tune ) &lt; <span class="hljs-number">0</span> )<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//根据输入的preset设置部分参数</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">param_apply_preset</span><span class="hljs-params">( <span class="hljs-type">x264_param_t</span> *param, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *preset )</span><br>&#123;<br>    <span class="hljs-type">char</span> *end;<br>    <span class="hljs-type">int</span> i = strtol( preset, &amp;end, <span class="hljs-number">10</span> );<br>    <span class="hljs-keyword">if</span>( *end == <span class="hljs-number">0</span> &amp;&amp; i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; ARRAY_ELEMS(x264_preset_names)<span class="hljs-number">-1</span> )<br>        preset = x264_preset_names[i];<br><br>    <span class="hljs-keyword">if</span>( !strcasecmp( preset, <span class="hljs-string">&quot;ultrafast&quot;</span> ) )<br>    &#123;<br>        param-&gt;i_frame_reference = <span class="hljs-number">1</span>;<br>        param-&gt;i_scenecut_threshold = <span class="hljs-number">0</span>;<br>        param-&gt;b_deblocking_filter = <span class="hljs-number">0</span>; <span class="hljs-comment">//关闭了去方块滤波</span><br>        param-&gt;b_cabac = <span class="hljs-number">0</span>;<br>        param-&gt;i_bframe = <span class="hljs-number">0</span>; <span class="hljs-comment">//无b帧</span><br>        param-&gt;analyse.intra = <span class="hljs-number">0</span>;<br>        param-&gt;analyse.inter = <span class="hljs-number">0</span>;<br>        param-&gt;analyse.b_transform_8x8 = <span class="hljs-number">0</span>; <span class="hljs-comment">//无8x8 DCT</span><br>        param-&gt;analyse.i_me_method = X264_ME_DIA; <span class="hljs-comment">//菱形搜索</span><br>        param-&gt;analyse.i_subpel_refine = <span class="hljs-number">0</span>;<br>        param-&gt;rc.i_aq_mode = <span class="hljs-number">0</span>;<br>        param-&gt;analyse.b_mixed_references = <span class="hljs-number">0</span>;<br>        param-&gt;analyse.i_trellis = <span class="hljs-number">0</span>;<br>        param-&gt;i_bframe_adaptive = X264_B_ADAPT_NONE;<br>        param-&gt;rc.b_mb_tree = <span class="hljs-number">0</span>;<br>        param-&gt;analyse.i_weighted_pred = X264_WEIGHTP_NONE;<br>        param-&gt;analyse.b_weighted_bipred = <span class="hljs-number">0</span>;<br>        param-&gt;rc.i_lookahead = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( !strcasecmp( preset, <span class="hljs-string">&quot;superfast&quot;</span> ) )<br>    &#123;<br>        param-&gt;analyse.inter = X264_ANALYSE_I8x8|X264_ANALYSE_I4x4;<br>        param-&gt;analyse.i_me_method = X264_ME_DIA;<br>        param-&gt;analyse.i_subpel_refine = <span class="hljs-number">1</span>;<br>        param-&gt;i_frame_reference = <span class="hljs-number">1</span>;<br>        param-&gt;analyse.b_mixed_references = <span class="hljs-number">0</span>;<br>        param-&gt;analyse.i_trellis = <span class="hljs-number">0</span>;<br>        param-&gt;rc.b_mb_tree = <span class="hljs-number">0</span>;<br>        param-&gt;analyse.i_weighted_pred = X264_WEIGHTP_SIMPLE;<br>        param-&gt;rc.i_lookahead = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( !strcasecmp( preset, <span class="hljs-string">&quot;veryfast&quot;</span> ) )<br>    &#123;<br>        param-&gt;analyse.i_subpel_refine = <span class="hljs-number">2</span>;<br>        param-&gt;i_frame_reference = <span class="hljs-number">1</span>;<br>        param-&gt;analyse.b_mixed_references = <span class="hljs-number">0</span>;<br>        param-&gt;analyse.i_trellis = <span class="hljs-number">0</span>;<br>        param-&gt;analyse.i_weighted_pred = X264_WEIGHTP_SIMPLE;<br>        param-&gt;rc.i_lookahead = <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( !strcasecmp( preset, <span class="hljs-string">&quot;faster&quot;</span> ) )<br>    &#123;<br>        param-&gt;analyse.b_mixed_references = <span class="hljs-number">0</span>;<br>        param-&gt;i_frame_reference = <span class="hljs-number">2</span>;<br>        param-&gt;analyse.i_subpel_refine = <span class="hljs-number">4</span>;<br>        param-&gt;analyse.i_weighted_pred = X264_WEIGHTP_SIMPLE;<br>        param-&gt;rc.i_lookahead = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( !strcasecmp( preset, <span class="hljs-string">&quot;fast&quot;</span> ) )<br>    &#123;<br>        param-&gt;i_frame_reference = <span class="hljs-number">2</span>;<br>        param-&gt;analyse.i_subpel_refine = <span class="hljs-number">6</span>;<br>        param-&gt;analyse.i_weighted_pred = X264_WEIGHTP_SIMPLE;<br>        param-&gt;rc.i_lookahead = <span class="hljs-number">30</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( !strcasecmp( preset, <span class="hljs-string">&quot;medium&quot;</span> ) )<br>    &#123;<br>        <span class="hljs-comment">/* Default is medium */</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( !strcasecmp( preset, <span class="hljs-string">&quot;slow&quot;</span> ) )<br>    &#123;<br>        param-&gt;analyse.i_subpel_refine = <span class="hljs-number">8</span>;<br>        param-&gt;i_frame_reference = <span class="hljs-number">5</span>;<br>        param-&gt;analyse.i_direct_mv_pred = X264_DIRECT_PRED_AUTO;<br>        param-&gt;analyse.i_trellis = <span class="hljs-number">2</span>;<br>        param-&gt;rc.i_lookahead = <span class="hljs-number">50</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( !strcasecmp( preset, <span class="hljs-string">&quot;slower&quot;</span> ) )<br>    &#123;<br>        param-&gt;analyse.i_me_method = X264_ME_UMH; <span class="hljs-comment">//非对称十字六边形网络搜索</span><br>        param-&gt;analyse.i_subpel_refine = <span class="hljs-number">9</span>;<br>        param-&gt;i_frame_reference = <span class="hljs-number">8</span>;<br>        param-&gt;i_bframe_adaptive = X264_B_ADAPT_TRELLIS;<br>        param-&gt;analyse.i_direct_mv_pred = X264_DIRECT_PRED_AUTO;<br>        param-&gt;analyse.inter |= X264_ANALYSE_PSUB8x8;<br>        param-&gt;analyse.i_trellis = <span class="hljs-number">2</span>;<br>        param-&gt;rc.i_lookahead = <span class="hljs-number">60</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( !strcasecmp( preset, <span class="hljs-string">&quot;veryslow&quot;</span> ) )<br>    &#123;<br>        param-&gt;analyse.i_me_method = X264_ME_UMH;<br>        param-&gt;analyse.i_subpel_refine = <span class="hljs-number">10</span>;<br>        param-&gt;analyse.i_me_range = <span class="hljs-number">24</span>;<br>        param-&gt;i_frame_reference = <span class="hljs-number">16</span>;<br>        param-&gt;i_bframe_adaptive = X264_B_ADAPT_TRELLIS;<br>        param-&gt;analyse.i_direct_mv_pred = X264_DIRECT_PRED_AUTO;<br>        param-&gt;analyse.inter |= X264_ANALYSE_PSUB8x8;<br>        param-&gt;analyse.i_trellis = <span class="hljs-number">2</span>;<br>        param-&gt;i_bframe = <span class="hljs-number">8</span>;<br>        param-&gt;rc.i_lookahead = <span class="hljs-number">60</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( !strcasecmp( preset, <span class="hljs-string">&quot;placebo&quot;</span> ) )<br>    &#123;<br>        param-&gt;analyse.i_me_method = X264_ME_TESA;<br>        param-&gt;analyse.i_subpel_refine = <span class="hljs-number">11</span>;<br>        param-&gt;analyse.i_me_range = <span class="hljs-number">24</span>;<br>        param-&gt;i_frame_reference = <span class="hljs-number">16</span>;<br>        param-&gt;i_bframe_adaptive = X264_B_ADAPT_TRELLIS;<br>        param-&gt;analyse.i_direct_mv_pred = X264_DIRECT_PRED_AUTO;<br>        param-&gt;analyse.inter |= X264_ANALYSE_PSUB8x8;<br>        param-&gt;analyse.b_fast_pskip = <span class="hljs-number">0</span>;<br>        param-&gt;analyse.i_trellis = <span class="hljs-number">2</span>;<br>        param-&gt;i_bframe = <span class="hljs-number">16</span>;<br>        param-&gt;rc.i_lookahead = <span class="hljs-number">60</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        x264_log_internal( X264_LOG_ERROR, <span class="hljs-string">&quot;invalid preset &#x27;%s&#x27;\n&quot;</span>, preset );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//设置tune</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">param_apply_tune</span><span class="hljs-params">( <span class="hljs-type">x264_param_t</span> *param, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *tune )</span><br>&#123;<br>    <span class="hljs-type">int</span> psy_tuning_used = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//这里是循环的，可以设置多个tune</span><br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> len; tune += <span class="hljs-built_in">strspn</span>( tune, <span class="hljs-string">&quot;,./-+&quot;</span> ), (len = <span class="hljs-built_in">strcspn</span>( tune, <span class="hljs-string">&quot;,./-+&quot;</span> )); tune += len )<br>    &#123;<br>        <span class="hljs-keyword">if</span>( len == <span class="hljs-number">4</span> &amp;&amp; !strncasecmp( tune, <span class="hljs-string">&quot;film&quot;</span>, <span class="hljs-number">4</span> ) )<br>        &#123;<br>            <span class="hljs-keyword">if</span>( psy_tuning_used++ ) <span class="hljs-keyword">goto</span> psy_failure;<br>            param-&gt;i_deblocking_filter_alphac0 = <span class="hljs-number">-1</span>;<br>            param-&gt;i_deblocking_filter_beta = <span class="hljs-number">-1</span>;<br>            param-&gt;analyse.f_psy_trellis = <span class="hljs-number">0.15</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( len == <span class="hljs-number">9</span> &amp;&amp; !strncasecmp( tune, <span class="hljs-string">&quot;animation&quot;</span>, <span class="hljs-number">9</span> ) )<br>        &#123;<br>            <span class="hljs-keyword">if</span>( psy_tuning_used++ ) <span class="hljs-keyword">goto</span> psy_failure;<br>            param-&gt;i_frame_reference = param-&gt;i_frame_reference &gt; <span class="hljs-number">1</span> ? param-&gt;i_frame_reference*<span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>            param-&gt;i_deblocking_filter_alphac0 = <span class="hljs-number">1</span>;<br>            param-&gt;i_deblocking_filter_beta = <span class="hljs-number">1</span>;<br>            param-&gt;analyse.f_psy_rd = <span class="hljs-number">0.4</span>;<br>            param-&gt;rc.f_aq_strength = <span class="hljs-number">0.6</span>;<br>            param-&gt;i_bframe += <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( len == <span class="hljs-number">5</span> &amp;&amp; !strncasecmp( tune, <span class="hljs-string">&quot;grain&quot;</span>, <span class="hljs-number">5</span> ) )<br>        &#123;<br>            <span class="hljs-keyword">if</span>( psy_tuning_used++ ) <span class="hljs-keyword">goto</span> psy_failure;<br>            param-&gt;i_deblocking_filter_alphac0 = <span class="hljs-number">-2</span>;<br>            param-&gt;i_deblocking_filter_beta = <span class="hljs-number">-2</span>;<br>            param-&gt;analyse.f_psy_trellis = <span class="hljs-number">0.25</span>;<br>            param-&gt;analyse.b_dct_decimate = <span class="hljs-number">0</span>;<br>            param-&gt;rc.f_pb_factor = <span class="hljs-number">1.1</span>;<br>            param-&gt;rc.f_ip_factor = <span class="hljs-number">1.1</span>;<br>            param-&gt;rc.f_aq_strength = <span class="hljs-number">0.5</span>;<br>            param-&gt;analyse.i_luma_deadzone[<span class="hljs-number">0</span>] = <span class="hljs-number">6</span>;<br>            param-&gt;analyse.i_luma_deadzone[<span class="hljs-number">1</span>] = <span class="hljs-number">6</span>;<br>            param-&gt;rc.f_qcompress = <span class="hljs-number">0.8</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( len == <span class="hljs-number">10</span> &amp;&amp; !strncasecmp( tune, <span class="hljs-string">&quot;stillimage&quot;</span>, <span class="hljs-number">10</span> ) )<br>        &#123;<br>            <span class="hljs-keyword">if</span>( psy_tuning_used++ ) <span class="hljs-keyword">goto</span> psy_failure;<br>            param-&gt;i_deblocking_filter_alphac0 = <span class="hljs-number">-3</span>;<br>            param-&gt;i_deblocking_filter_beta = <span class="hljs-number">-3</span>;<br>            param-&gt;analyse.f_psy_rd = <span class="hljs-number">2.0</span>;<br>            param-&gt;analyse.f_psy_trellis = <span class="hljs-number">0.7</span>;<br>            param-&gt;rc.f_aq_strength = <span class="hljs-number">1.2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( len == <span class="hljs-number">4</span> &amp;&amp; !strncasecmp( tune, <span class="hljs-string">&quot;psnr&quot;</span>, <span class="hljs-number">4</span> ) )<br>        &#123;<br>            <span class="hljs-keyword">if</span>( psy_tuning_used++ ) <span class="hljs-keyword">goto</span> psy_failure;<br>            param-&gt;rc.i_aq_mode = X264_AQ_NONE;<br>            param-&gt;analyse.b_psy = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( len == <span class="hljs-number">4</span> &amp;&amp; !strncasecmp( tune, <span class="hljs-string">&quot;ssim&quot;</span>, <span class="hljs-number">4</span> ) )<br>        &#123;<br>            <span class="hljs-keyword">if</span>( psy_tuning_used++ ) <span class="hljs-keyword">goto</span> psy_failure;<br>            param-&gt;rc.i_aq_mode = X264_AQ_AUTOVARIANCE;<br>            param-&gt;analyse.b_psy = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( len == <span class="hljs-number">10</span> &amp;&amp; !strncasecmp( tune, <span class="hljs-string">&quot;fastdecode&quot;</span>, <span class="hljs-number">10</span> ) )<br>        &#123;<br>            param-&gt;b_deblocking_filter = <span class="hljs-number">0</span>;<br>            param-&gt;b_cabac = <span class="hljs-number">0</span>;<br>            param-&gt;analyse.b_weighted_bipred = <span class="hljs-number">0</span>;<br>            param-&gt;analyse.i_weighted_pred = X264_WEIGHTP_NONE;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( len == <span class="hljs-number">11</span> &amp;&amp; !strncasecmp( tune, <span class="hljs-string">&quot;zerolatency&quot;</span>, <span class="hljs-number">11</span> ) )<br>        &#123;<br>            param-&gt;rc.i_lookahead = <span class="hljs-number">0</span>; <br>            param-&gt;i_sync_lookahead = <span class="hljs-number">0</span>;<br>            param-&gt;i_bframe = <span class="hljs-number">0</span>; <span class="hljs-comment">//关闭b帧</span><br>            param-&gt;b_sliced_threads = <span class="hljs-number">1</span>;<br>            param-&gt;b_vfr_input = <span class="hljs-number">0</span>;<br>            param-&gt;rc.b_mb_tree = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( len == <span class="hljs-number">6</span> &amp;&amp; !strncasecmp( tune, <span class="hljs-string">&quot;touhou&quot;</span>, <span class="hljs-number">6</span> ) )<br>        &#123;<br>            <span class="hljs-keyword">if</span>( psy_tuning_used++ ) <span class="hljs-keyword">goto</span> psy_failure;<br>            param-&gt;i_frame_reference = param-&gt;i_frame_reference &gt; <span class="hljs-number">1</span> ? param-&gt;i_frame_reference*<span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>            param-&gt;i_deblocking_filter_alphac0 = <span class="hljs-number">-1</span>;<br>            param-&gt;i_deblocking_filter_beta = <span class="hljs-number">-1</span>;<br>            param-&gt;analyse.f_psy_trellis = <span class="hljs-number">0.2</span>;<br>            param-&gt;rc.f_aq_strength = <span class="hljs-number">1.3</span>;<br>            <span class="hljs-keyword">if</span>( param-&gt;analyse.inter &amp; X264_ANALYSE_PSUB16x16 )<br>                param-&gt;analyse.inter |= X264_ANALYSE_PSUB8x8;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            x264_log_internal( X264_LOG_ERROR, <span class="hljs-string">&quot;invalid tune &#x27;%.*s&#x27;\n&quot;</span>, len, tune );<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    psy_failure:<br>            x264_log_internal( X264_LOG_WARNING, <span class="hljs-string">&quot;only 1 psy tuning can be used: ignoring tune %.*s\n&quot;</span>, len, tune );<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="encode-amp-param-amp-opt"><a href="#encode-amp-param-amp-opt" class="headerlink" title="encode( &amp;param, &amp;opt )"></a>encode( &amp;param, &amp;opt )</h4><p>encode是真正的编码处理，代码开头定义部分如下，开头几个是x264的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">encode</span><span class="hljs-params">( <span class="hljs-type">x264_param_t</span> *param, <span class="hljs-type">cli_opt_t</span> *opt )</span><br>&#123;<br>    <span class="hljs-type">x264_t</span> *h = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 编码器</span><br>    <span class="hljs-type">x264_picture_t</span> pic; <span class="hljs-comment">// 图像信息</span><br>    <span class="hljs-type">cli_pic_t</span> cli_pic; <span class="hljs-comment">//cli用的图片的信息</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">cli_pulldown_t</span> *pulldown = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// shut up gcc</span><br><br>    <span class="hljs-type">int</span>     i_frame = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>     i_frame_output = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int64_t</span> i_end, i_previous = <span class="hljs-number">0</span>, i_start = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int64_t</span> i_file = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>     i_frame_size;<br>    <span class="hljs-type">int64_t</span> last_dts = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int64_t</span> prev_dts = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int64_t</span> first_dts = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#   <span class="hljs-keyword">define</span>  MAX_PTS_WARNING 3 <span class="hljs-comment">/* arbitrary */</span></span><br>    <span class="hljs-type">int</span>     pts_warning_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int64_t</span> largest_pts = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int64_t</span> second_largest_pts = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int64_t</span> ticks_per_frame;<br>    <span class="hljs-type">double</span>  duration;<br>    <span class="hljs-type">double</span>  pulldown_pts = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>     retval = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>encode 的主要工作是初始化结构体后调用encode_frame函数编码，而encode_frame调用了x264_encoder_encode进行实际的编码。这个函数位于encoder&#x2F;api.c，是个调用函数指针的封装：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">REALIGN_STACK <span class="hljs-type">int</span> <span class="hljs-title function_">x264_encoder_encode</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *h, <span class="hljs-type">x264_nal_t</span> **pp_nal, <span class="hljs-type">int</span> *pi_nal, <span class="hljs-type">x264_picture_t</span> *pic_in, <span class="hljs-type">x264_picture_t</span> *pic_out )</span><br>&#123;<br>    <span class="hljs-type">x264_api_t</span> *api = (<span class="hljs-type">x264_api_t</span> *)h;<br><br>    <span class="hljs-keyword">return</span> api-&gt;encoder_encode( api-&gt;x264, pp_nal, pi_nal, pic_in, pic_out );<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，回到编码器开启的时候寻找当时注册的encode函数，这个注册过程同样实现在encoder&#x2F;api.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c">REALIGN_STACK <span class="hljs-type">x264_t</span> *<span class="hljs-title function_">x264_encoder_open</span><span class="hljs-params">( <span class="hljs-type">x264_param_t</span> *param )</span><br>&#123;<br>    <span class="hljs-type">x264_api_t</span> *api = <span class="hljs-built_in">calloc</span>( <span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>( <span class="hljs-type">x264_api_t</span> ) );<br>    <span class="hljs-keyword">if</span>( !api )<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">if</span>( HAVE_BITDEPTH8 &amp;&amp; param-&gt;i_bitdepth == <span class="hljs-number">8</span> )<br>    &#123;<br>        api-&gt;nal_encode = x264_8_nal_encode;<br>        api-&gt;encoder_reconfig = x264_8_encoder_reconfig;<br>        api-&gt;encoder_parameters = x264_8_encoder_parameters;<br>        api-&gt;encoder_headers = x264_8_encoder_headers;<br>        api-&gt;encoder_encode = x264_8_encoder_encode;<br>        api-&gt;encoder_close = x264_8_encoder_close;<br>        api-&gt;encoder_delayed_frames = x264_8_encoder_delayed_frames;<br>        api-&gt;encoder_maximum_delayed_frames = x264_8_encoder_maximum_delayed_frames;<br>        api-&gt;encoder_intra_refresh = x264_8_encoder_intra_refresh;<br>        api-&gt;encoder_invalidate_reference = x264_8_encoder_invalidate_reference;<br><br>        api-&gt;x264 = x264_8_encoder_open( param );<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( HAVE_BITDEPTH10 &amp;&amp; param-&gt;i_bitdepth == <span class="hljs-number">10</span> )<br>    &#123;<br>        api-&gt;nal_encode = x264_10_nal_encode;<br>        api-&gt;encoder_reconfig = x264_10_encoder_reconfig;<br>        api-&gt;encoder_parameters = x264_10_encoder_parameters;<br>        api-&gt;encoder_headers = x264_10_encoder_headers;<br>        api-&gt;encoder_encode = x264_10_encoder_encode;<br>        api-&gt;encoder_close = x264_10_encoder_close;<br>        api-&gt;encoder_delayed_frames = x264_10_encoder_delayed_frames;<br>        api-&gt;encoder_maximum_delayed_frames = x264_10_encoder_maximum_delayed_frames;<br>        api-&gt;encoder_intra_refresh = x264_10_encoder_intra_refresh;<br>        api-&gt;encoder_invalidate_reference = x264_10_encoder_invalidate_reference;<br><br>        api-&gt;x264 = x264_10_encoder_open( param );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        x264_log_internal( X264_LOG_ERROR, <span class="hljs-string">&quot;not compiled with %d bit depth support\n&quot;</span>, param-&gt;i_bitdepth );<br><br>    <span class="hljs-keyword">if</span>( !api-&gt;x264 )<br>    &#123;<br>        <span class="hljs-built_in">free</span>( api );<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* x264_t is opaque */</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">x264_t</span> *)api;<br>&#125;<br></code></pre></td></tr></table></figure><p>目前x264主要是按照8bit和10bit两种不同的深度对调用进行了注册。但是全文搜索并找不到这些指向的函数实现，只能找到定义，同样位于encoder&#x2F;api.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">x264_t</span> *<span class="hljs-title function_">x264_8_encoder_open</span><span class="hljs-params">( <span class="hljs-type">x264_param_t</span> * )</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">x264_8_nal_encode</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *h, <span class="hljs-type">uint8_t</span> *dst, <span class="hljs-type">x264_nal_t</span> *nal )</span>;<br><span class="hljs-type">int</span>  <span class="hljs-title function_">x264_8_encoder_reconfig</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *, <span class="hljs-type">x264_param_t</span> * )</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">x264_8_encoder_parameters</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *, <span class="hljs-type">x264_param_t</span> * )</span>;<br><span class="hljs-type">int</span>  <span class="hljs-title function_">x264_8_encoder_headers</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *, <span class="hljs-type">x264_nal_t</span> **pp_nal, <span class="hljs-type">int</span> *pi_nal )</span>;<br><span class="hljs-type">int</span>  <span class="hljs-title function_">x264_8_encoder_encode</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *, <span class="hljs-type">x264_nal_t</span> **pp_nal, <span class="hljs-type">int</span> *pi_nal, <span class="hljs-type">x264_picture_t</span> *pic_in, <span class="hljs-type">x264_picture_t</span> *pic_out )</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">x264_8_encoder_close</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> * )</span>;<br><span class="hljs-type">int</span>  <span class="hljs-title function_">x264_8_encoder_delayed_frames</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> * )</span>;<br><span class="hljs-type">int</span>  <span class="hljs-title function_">x264_8_encoder_maximum_delayed_frames</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> * )</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">x264_8_encoder_intra_refresh</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> * )</span>;<br><span class="hljs-type">int</span>  <span class="hljs-title function_">x264_8_encoder_invalidate_reference</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *, <span class="hljs-type">int64_t</span> pts )</span>;<br><br><span class="hljs-type">x264_t</span> *<span class="hljs-title function_">x264_10_encoder_open</span><span class="hljs-params">( <span class="hljs-type">x264_param_t</span> * )</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">x264_10_nal_encode</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *h, <span class="hljs-type">uint8_t</span> *dst, <span class="hljs-type">x264_nal_t</span> *nal )</span>;<br><span class="hljs-type">int</span>  <span class="hljs-title function_">x264_10_encoder_reconfig</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *, <span class="hljs-type">x264_param_t</span> * )</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">x264_10_encoder_parameters</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *, <span class="hljs-type">x264_param_t</span> * )</span>;<br><span class="hljs-type">int</span>  <span class="hljs-title function_">x264_10_encoder_headers</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *, <span class="hljs-type">x264_nal_t</span> **pp_nal, <span class="hljs-type">int</span> *pi_nal )</span>;<br><span class="hljs-type">int</span>  <span class="hljs-title function_">x264_10_encoder_encode</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *, <span class="hljs-type">x264_nal_t</span> **pp_nal, <span class="hljs-type">int</span> *pi_nal, <span class="hljs-type">x264_picture_t</span> *pic_in, <span class="hljs-type">x264_picture_t</span> *pic_out )</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">x264_10_encoder_close</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> * )</span>;<br><span class="hljs-type">int</span>  <span class="hljs-title function_">x264_10_encoder_delayed_frames</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> * )</span>;<br><span class="hljs-type">int</span>  <span class="hljs-title function_">x264_10_encoder_maximum_delayed_frames</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> * )</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">x264_10_encoder_intra_refresh</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> * )</span>;<br><span class="hljs-type">int</span>  <span class="hljs-title function_">x264_10_encoder_invalidate_reference</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *, <span class="hljs-type">int64_t</span> pts )</span>;<br></code></pre></td></tr></table></figure><p>在编译后，可以看到x264会生成两种不同位深的.o文件，例如在encoder&#x2F;：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"> &gt; <span class="hljs-built_in">ls</span><br>analyse-10.o  cavlc-8.o        macroblock.c      rdo.c<br>analyse-8.o   cavlc.c          macroblock.h      set-10.o<br>analyse.c     encoder-10.o     me-10.o           set-8.o<br>analyse.h     encoder-8.o      me-8.o            set.c<br>api.c         encoder.c        me.c              set.h<br>api.o         lookahead-10.o   me.h              slicetype.c<br>cabac-10.o    lookahead-8.o    ratecontrol-10.o  slicetype-cl-8.o<br>cabac-8.o     lookahead.c      ratecontrol-8.o   slicetype-cl.c<br>cabac.c       macroblock-10.o  ratecontrol.c     slicetype-cl.h<br>cavlc-10.o    macroblock-8.o   ratecontrol.h<br></code></pre></td></tr></table></figure><p>全局搜索可以看到，相关的实现被x264通过宏定义进行区分(common&#x2F;common.h):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Macros for templating function calls according to bit depth */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x264_template(w) x264_glue3(x264, BIT_DEPTH, w)</span><br><br><span class="hljs-comment">/****************************************************************************</span><br><span class="hljs-comment"> * API Templates</span><br><span class="hljs-comment"> ****************************************************************************/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x264_nal_encode x264_template(nal_encode)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x264_encoder_reconfig x264_template(encoder_reconfig)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x264_encoder_parameters x264_template(encoder_parameters)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x264_encoder_headers x264_template(encoder_headers)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x264_encoder_encode x264_template(encoder_encode)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x264_encoder_close x264_template(encoder_close)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x264_encoder_delayed_frames x264_template(encoder_delayed_frames)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x264_encoder_maximum_delayed_frames x264_template(encoder_maximum_delayed_frames)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x264_encoder_intra_refresh x264_template(encoder_intra_refresh)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x264_encoder_invalidate_reference x264_template(encoder_invalidate_reference) </span><br></code></pre></td></tr></table></figure><p>因此，无论是8bit还是10bit的处理，在API逻辑上没有区别。</p><p>上文API的实现位于encoder&#x2F;encoder.c，现在再回头看之前寻找的编码函数，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/****************************************************************************</span><br><span class="hljs-comment"> * x264_encoder_encode:</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">XXX:</span> i_poc   : is the poc of the current given picture</span><br><span class="hljs-comment"> *       i_frame : is the number of the frame being coded</span><br><span class="hljs-comment"> *  ex:  type frame poc</span><br><span class="hljs-comment"> *       I      0   2*0</span><br><span class="hljs-comment"> *       P      1   2*3</span><br><span class="hljs-comment"> *       B      2   2*1</span><br><span class="hljs-comment"> *       B      3   2*2</span><br><span class="hljs-comment"> *       P      4   2*6</span><br><span class="hljs-comment"> *       B      5   2*4</span><br><span class="hljs-comment"> *       B      6   2*5</span><br><span class="hljs-comment"> ****************************************************************************/</span><br><span class="hljs-type">int</span>     <span class="hljs-title function_">x264_encoder_encode</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *h,</span><br><span class="hljs-params">                             <span class="hljs-type">x264_nal_t</span> **pp_nal, <span class="hljs-type">int</span> *pi_nal,</span><br><span class="hljs-params">                             <span class="hljs-type">x264_picture_t</span> *pic_in,</span><br><span class="hljs-params">                             <span class="hljs-type">x264_picture_t</span> *pic_out )</span> <br></code></pre></td></tr></table></figure><p>该函数的入参如下：</p><pre><code class="hljs"> 1. x264_t *h编码器参数 2. x264_nal_t **pp_nal 编码的结果 3. int *pi_nal 已编码的帧数 4. x264_picture_t *pic_in 存放输入的raw数据 5. x264_picture_t *pic_out</code></pre><p>主要调用的函数:</p><ol><li>x264_frame_pop_unused 获取一个没有使用的frame(fenc)</li><li>x264_frame_copy_picture 拷贝raw数据到fenc</li><li>x264_frame_expand_border_mod16 对分辨率不是16倍数的帧，增加pad位进行扩边 </li><li>x264_macroblock_tree_read mb-tree相关的码率控制</li><li>x264_adaptive_quant_frame 宏块级码率控制</li><li>x264_frame_init_lowres 1&#x2F;2像素的内插</li><li>x264_lookahead_put_frame 将帧加入lookahead分析</li><li>x264_lookahead_get_frames 从lookahead取出帧</li><li>x264_frame_shift 从队列中取出用于编码的帧</li><li>x264_ratecontrol_zone_init 码率控制初始化</li><li>reference_reset 清空参考帧列表</li><li>reference_hierarchy_reset 在帧类型为I帧，P帧等类型时，调用判断是否重置参考帧</li><li>reference_build_list 建立参考帧列表，list0，list1</li><li>x264_ratecontrol_start 开启码率控制，选择合适的QP</li><li>x264_ratecontrol_qp 获取计算出的QP</li><li>slice_init 创建头信息</li><li>slices_write 真正的编码函数，内部进行了编码</li><li>encoder_frame_end 编码后的处理内容</li></ol><h4 id="码率控制"><a href="#码率控制" class="headerlink" title="码率控制"></a>码率控制</h4><p>x264_ratecontrol相关的处理被定义在encoder&#x2F;ratecontrol.c当中。其中，x264_ratecontrol_start的ratecontrol针对的是帧层级的计算。在该函数中，主要进行帧预期QP值的运算，主要使用ABR，2-PASS和VBV三种控制方式。</p><h5 id="ABR算法-amp-amp-2-PASS-ABR"><a href="#ABR算法-amp-amp-2-PASS-ABR" class="headerlink" title="ABR算法 &amp;&amp; 2-PASS ABR"></a>ABR算法 &amp;&amp; 2-PASS ABR</h5><p>在x264_ratecontrol_start函数中, 关于ABR和2-PASS ABR计算，主要是如下几行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>( rc-&gt;b_abr )<br>&#123;<br>    q = qscale2qp( rate_estimate_qscale( h ) );<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( rc-&gt;b_2pass )<br>&#123;<br>    rce-&gt;new_qscale = rate_estimate_qscale( h );<br>    q = qscale2qp( rce-&gt;new_qscale );<br>&#125;<br></code></pre></td></tr></table></figure><p>其中q代表ABR算法计算的QP值；下面分析函数的调用（这里看的是原生代码，不是优化后代码）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> QP_BD_OFFSET (6*(BIT_DEPTH-8))</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">float</span> <span class="hljs-title function_">qscale2qp</span><span class="hljs-params">( <span class="hljs-type">float</span> qscale )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">12.0f</span> + QP_BD_OFFSET) + <span class="hljs-number">6.0f</span> * log2f( qscale/<span class="hljs-number">0.85f</span> );<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数代表了计算ABR的换算公式，x264选择了固定的公式（经验公式）换算qscale和qp。此时查看反向的切换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">float</span> <span class="hljs-title function_">qp2qscale</span><span class="hljs-params">( <span class="hljs-type">float</span> qp )</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.85f</span> * powf( <span class="hljs-number">2.0f</span>, ( qp - (<span class="hljs-number">12.0f</span> + QP_BD_OFFSET) ) / <span class="hljs-number">6.0f</span> );<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到公式为 （假设是8bit位深）<br>$$<br>qscale &#x3D; 0.85*2.0^{(qp - 12.0)&#x2F;6.0}<br>$$<br>qscale和每帧的bits也存在线性关系，因此先计算qscale，再转换成qp即可进行码率初步控制；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// update qscale for 1 frame based on actual bits used so far</span><br><span class="hljs-type">static</span> <span class="hljs-type">float</span> <span class="hljs-title function_">rate_estimate_qscale</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *h )</span><br>&#123;<br>    <span class="hljs-type">float</span> q;<br>    <span class="hljs-type">x264_ratecontrol_t</span> *rcc = h-&gt;rc;<br>    <span class="hljs-type">ratecontrol_entry_t</span> rce = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> pict_type = h-&gt;sh.i_type;<br>    <span class="hljs-comment">// 这里进行总的比特的计算</span><br>    <span class="hljs-type">int64_t</span> total_bits = <span class="hljs-number">8</span>*(h-&gt;stat.i_frame_size[SLICE_TYPE_I] <br>                          + h-&gt;stat.i_frame_size[SLICE_TYPE_P]<br>                          + h-&gt;stat.i_frame_size[SLICE_TYPE_B])<br>                       - rcc-&gt;filler_bits_sum; <span class="hljs-comment">//这里减掉了帧填充数据</span><br><br>    <span class="hljs-comment">//如果2pass获取句柄</span><br>    <span class="hljs-keyword">if</span>( rcc-&gt;b_2pass )<br>    &#123;<br>        rce = *rcc-&gt;rce;<br>        <span class="hljs-keyword">if</span>( pict_type != rce.pict_type )<br>        &#123;<br>            x264_log( h, X264_LOG_ERROR, <span class="hljs-string">&quot;slice=%c but 2pass stats say %c\n&quot;</span>,<br>                      slice_type_to_char[pict_type], slice_type_to_char[rce.pict_type] );<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( pict_type == SLICE_TYPE_B )<br>    &#123;<br>        <span class="hljs-comment">/* B-frames don&#x27;t have independent ratecontrol, but rather get the</span><br><span class="hljs-comment">         * average QP of the two adjacent P-frames + an offset */</span><br><br>        <span class="hljs-type">int</span> i0 = IS_X264_TYPE_I(h-&gt;fref_nearest[<span class="hljs-number">0</span>]-&gt;i_type);<br>        <span class="hljs-type">int</span> i1 = IS_X264_TYPE_I(h-&gt;fref_nearest[<span class="hljs-number">1</span>]-&gt;i_type);<br>        <span class="hljs-type">int</span> dt0 = <span class="hljs-built_in">abs</span>(h-&gt;fenc-&gt;i_poc - h-&gt;fref_nearest[<span class="hljs-number">0</span>]-&gt;i_poc);<br>        <span class="hljs-type">int</span> dt1 = <span class="hljs-built_in">abs</span>(h-&gt;fenc-&gt;i_poc - h-&gt;fref_nearest[<span class="hljs-number">1</span>]-&gt;i_poc);<br>        <span class="hljs-type">float</span> q0 = h-&gt;fref_nearest[<span class="hljs-number">0</span>]-&gt;f_qp_avg_rc;<br>        <span class="hljs-type">float</span> q1 = h-&gt;fref_nearest[<span class="hljs-number">1</span>]-&gt;f_qp_avg_rc;<br><br>        <span class="hljs-keyword">if</span>( h-&gt;fref_nearest[<span class="hljs-number">0</span>]-&gt;i_type == X264_TYPE_BREF )<br>            q0 -= rcc-&gt;pb_offset/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>( h-&gt;fref_nearest[<span class="hljs-number">1</span>]-&gt;i_type == X264_TYPE_BREF )<br>            q1 -= rcc-&gt;pb_offset/<span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span>( i0 &amp;&amp; i1 )<br>            q = (q0 + q1) / <span class="hljs-number">2</span> + rcc-&gt;ip_offset;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( i0 )<br>            q = q1;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( i1 )<br>            q = q0;<br>        <span class="hljs-keyword">else</span><br>            q = (q0*dt1 + q1*dt0) / (dt0 + dt1);<br><br>        <span class="hljs-keyword">if</span>( h-&gt;fenc-&gt;b_kept_as_ref )<br>            q += rcc-&gt;pb_offset/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span><br>            q += rcc-&gt;pb_offset;<br><br>        rcc-&gt;qp_novbv = q;<br>        q = qp2qscale( q );<br>        <span class="hljs-comment">//估算当前帧的体积</span><br>        <span class="hljs-keyword">if</span>( rcc-&gt;b_2pass )<br>            rcc-&gt;frame_size_planned = qscale2bits( &amp;rce, q );<br>        <span class="hljs-keyword">else</span><br>            rcc-&gt;frame_size_planned = predict_size( rcc-&gt;pred_b_from_p, q, h-&gt;fref[<span class="hljs-number">1</span>][h-&gt;i_ref[<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>]-&gt;i_satd );<br>        <span class="hljs-comment">/* Limit planned size by MinCR */</span><br>        <span class="hljs-keyword">if</span>( rcc-&gt;b_vbv )<br>            rcc-&gt;frame_size_planned = X264_MIN( rcc-&gt;frame_size_planned, rcc-&gt;frame_size_maximum );<br>        rcc-&gt;frame_size_estimated = rcc-&gt;frame_size_planned;<br><br>        <span class="hljs-comment">/* For row SATDs */</span><br>        <span class="hljs-keyword">if</span>( rcc-&gt;b_vbv )<br>            rcc-&gt;last_satd = x264_rc_analyse_slice( h );<br>        <span class="hljs-keyword">return</span> q;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">double</span> abr_buffer = <span class="hljs-number">2</span> * rcc-&gt;rate_tolerance * rcc-&gt;bitrate;<br>        <span class="hljs-type">double</span> predicted_bits = total_bits;<br>        <span class="hljs-comment">//多线程更新predict_bits</span><br>        <span class="hljs-keyword">if</span>( h-&gt;i_thread_frames &gt; <span class="hljs-number">1</span> )<br>        &#123;<br>            <span class="hljs-type">int</span> j = rcc - h-&gt;thread[<span class="hljs-number">0</span>]-&gt;rc;<br>            <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; h-&gt;i_thread_frames; i++ )<br>            &#123;<br>                <span class="hljs-type">x264_t</span> *t = h-&gt;thread[(j+i) % h-&gt;i_thread_frames];<br>                <span class="hljs-type">double</span> bits = t-&gt;rc-&gt;frame_size_planned;<br>                <span class="hljs-keyword">if</span>( !t-&gt;b_thread_active )<br>                    <span class="hljs-keyword">continue</span>;<br>                bits = X264_MAX(bits, t-&gt;rc-&gt;frame_size_estimated);<br>                predicted_bits += bits;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>( rcc-&gt;b_2pass )<br>        &#123;<br>            <span class="hljs-type">double</span> lmin = rcc-&gt;lmin[pict_type];<br>            <span class="hljs-type">double</span> lmax = rcc-&gt;lmax[pict_type];<br>            <span class="hljs-type">double</span> diff;<br><br>            <span class="hljs-comment">/* Adjust ABR buffer based on distance to the end of the video. */</span><br>            <span class="hljs-keyword">if</span>( rcc-&gt;num_entries &gt; h-&gt;i_frame )<br>            &#123;<br>                <span class="hljs-type">double</span> final_bits = rcc-&gt;entry_out[rcc-&gt;num_entries<span class="hljs-number">-1</span>]-&gt;expected_bits;<br>                <span class="hljs-type">double</span> video_pos = rce.expected_bits / final_bits;<br>                <span class="hljs-type">double</span> scale_factor = <span class="hljs-built_in">sqrt</span>( (<span class="hljs-number">1</span> - video_pos) * rcc-&gt;num_entries );<br>                abr_buffer *= <span class="hljs-number">0.5</span> * X264_MAX( scale_factor, <span class="hljs-number">0.5</span> );<br>            &#125;<br><br>            diff = predicted_bits - rce.expected_bits;<br>            q = rce.new_qscale;<br>            q /= x264_clip3f((abr_buffer - diff) / abr_buffer, <span class="hljs-number">.5</span>, <span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">if</span>( h-&gt;i_frame &gt;= rcc-&gt;fps &amp;&amp; rcc-&gt;expected_bits_sum &gt;= <span class="hljs-number">1</span> )<br>            &#123;<br>                <span class="hljs-comment">/* Adjust quant based on the difference between</span><br><span class="hljs-comment">                 * achieved and expected bitrate so far */</span><br>                <span class="hljs-type">double</span> cur_time = (<span class="hljs-type">double</span>)h-&gt;i_frame / rcc-&gt;num_entries;<br>                <span class="hljs-type">double</span> w = x264_clip3f( cur_time*<span class="hljs-number">100</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> );<br>                q *= <span class="hljs-built_in">pow</span>( (<span class="hljs-type">double</span>)total_bits / rcc-&gt;expected_bits_sum, w );<br>            &#125;<br>            rcc-&gt;qp_novbv = qscale2qp( q );<br>            <span class="hljs-keyword">if</span>( rcc-&gt;b_vbv )<br>            &#123;<br>                <span class="hljs-comment">/* Do not overflow vbv */</span><br>                <span class="hljs-type">double</span> expected_size = qscale2bits( &amp;rce, q );<br>                <span class="hljs-type">double</span> expected_vbv = rcc-&gt;buffer_fill + rcc-&gt;buffer_rate - expected_size;<br>                <span class="hljs-type">double</span> expected_fullness = rce.expected_vbv / rcc-&gt;buffer_size;<br>                <span class="hljs-type">double</span> qmax = q*(<span class="hljs-number">2</span> - expected_fullness);<br>                <span class="hljs-type">double</span> size_constraint = <span class="hljs-number">1</span> + expected_fullness;<br>                qmax = X264_MAX( qmax, rce.new_qscale );<br>                <span class="hljs-keyword">if</span>( expected_fullness &lt; <span class="hljs-number">.05</span> )<br>                    qmax = lmax;<br>                qmax = X264_MIN(qmax, lmax);<br>                <span class="hljs-keyword">while</span>( ((expected_vbv &lt; rce.expected_vbv/size_constraint) &amp;&amp; (q &lt; qmax)) ||<br>                        ((expected_vbv &lt; <span class="hljs-number">0</span>) &amp;&amp; (q &lt; lmax)))<br>                &#123;<br>                    q *= <span class="hljs-number">1.05</span>;<br>                    expected_size = qscale2bits(&amp;rce, q);<br>                    expected_vbv = rcc-&gt;buffer_fill + rcc-&gt;buffer_rate - expected_size;<br>                &#125;<br>                rcc-&gt;last_satd = x264_rc_analyse_slice( h );<br>            &#125;<br>            q = x264_clip3f( q, lmin, lmax );<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">/* 1pass ABR */</span><br>        &#123;<br>            <span class="hljs-comment">/* Calculate the quantizer which would have produced the desired</span><br><span class="hljs-comment">             * average bitrate if it had been applied to all frames so far.</span><br><span class="hljs-comment">             * Then modulate that quant based on the current frame&#x27;s complexity</span><br><span class="hljs-comment">             * relative to the average complexity so far (using the 2pass RCEQ).</span><br><span class="hljs-comment">             * Then bias the quant up or down if total size so far was far from</span><br><span class="hljs-comment">             * the target.</span><br><span class="hljs-comment">             * Result: Depending on the value of rate_tolerance, there is a</span><br><span class="hljs-comment">             * tradeoff between quality and bitrate precision. But at large</span><br><span class="hljs-comment">             * tolerances, the bit distribution approaches that of 2pass. */</span><br><br>            <span class="hljs-type">double</span> wanted_bits, overflow = <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">//获取最新的satd</span><br>            rcc-&gt;last_satd = x264_rc_analyse_slice( h );<br>            <span class="hljs-comment">//更新cplxsum和cplxcount</span><br>            rcc-&gt;short_term_cplxsum *= <span class="hljs-number">0.5</span>;<br>            rcc-&gt;short_term_cplxcount *= <span class="hljs-number">0.5</span>;<br>            rcc-&gt;short_term_cplxsum += rcc-&gt;last_satd / (CLIP_DURATION(h-&gt;fenc-&gt;f_duration) / BASE_FRAME_DURATION);<br>            rcc-&gt;short_term_cplxcount ++;<br><br>            <span class="hljs-comment">//rce的初始化</span><br>            rce.tex_bits = rcc-&gt;last_satd;<br>            rce.blurred_complexity = rcc-&gt;short_term_cplxsum / rcc-&gt;short_term_cplxcount;<br>            rce.mv_bits = <span class="hljs-number">0</span>;<br>            rce.p_count = rcc-&gt;nmb;<br>            rce.i_count = <span class="hljs-number">0</span>;<br>            rce.s_count = <span class="hljs-number">0</span>;<br>            rce.qscale = <span class="hljs-number">1</span>;<br>            rce.pict_type = pict_type;<br>            rce.i_duration = h-&gt;fenc-&gt;i_duration;<br><br>            <span class="hljs-keyword">if</span>( h-&gt;param.rc.i_rc_method == X264_RC_CRF ) <span class="hljs-comment">//crf</span><br>            &#123;<br>                q = get_qscale( h, &amp;rce, rcc-&gt;rate_factor_constant, h-&gt;fenc-&gt;i_frame );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                q = get_qscale( h, &amp;rce, rcc-&gt;wanted_bits_window / rcc-&gt;cplxr_sum, h-&gt;fenc-&gt;i_frame );<br><br>                <span class="hljs-comment">/* ABR code can potentially be counterproductive in CBR, so just don&#x27;t bother.</span><br><span class="hljs-comment">                 * Don&#x27;t run it if the frame complexity is zero either. */</span><br>                <span class="hljs-keyword">if</span>( !rcc-&gt;b_vbv_min_rate &amp;&amp; rcc-&gt;last_satd ) <span class="hljs-comment">//没开启vbv就进行二次调整</span><br>                &#123;<br>                    <span class="hljs-comment">// FIXME is it simpler to keep track of wanted_bits in ratecontrol_end?</span><br>                    <span class="hljs-type">int</span> i_frame_done = h-&gt;i_frame;<br>                    <span class="hljs-comment">//播放需要的时间</span><br>                    <span class="hljs-type">double</span> time_done = i_frame_done / rcc-&gt;fps;<br>                    <span class="hljs-keyword">if</span>( h-&gt;param.b_vfr_input &amp;&amp; i_frame_done &gt; <span class="hljs-number">0</span> )<br>                        time_done = ((<span class="hljs-type">double</span>)(h-&gt;fenc-&gt;i_reordered_pts - h-&gt;i_reordered_pts_delay)) * h-&gt;param.i_timebase_num / h-&gt;param.i_timebase_den;<br>                    wanted_bits = time_done * rcc-&gt;bitrate;<br>                    <span class="hljs-keyword">if</span>( wanted_bits &gt; <span class="hljs-number">0</span> )<br>                    &#123;<br>                        abr_buffer *= X264_MAX( <span class="hljs-number">1</span>, <span class="hljs-built_in">sqrt</span>( time_done ) );<br>                        overflow = x264_clip3f( <span class="hljs-number">1.0</span> + (predicted_bits - wanted_bits) / abr_buffer, <span class="hljs-number">.5</span>, <span class="hljs-number">2</span> );<br>                        q *= overflow;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>( pict_type == SLICE_TYPE_I &amp;&amp; h-&gt;param.i_keyint_max &gt; <span class="hljs-number">1</span><br>                <span class="hljs-comment">/* should test _next_ pict type, but that isn&#x27;t decided yet */</span><br>                &amp;&amp; rcc-&gt;last_non_b_pict_type != SLICE_TYPE_I )<br>            &#123;<br>                q = qp2qscale( rcc-&gt;accum_p_qp / rcc-&gt;accum_p_norm );<br>                q /= h-&gt;param.rc.f_ip_factor;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( h-&gt;i_frame &gt; <span class="hljs-number">0</span> )<br>            &#123;<br>                <span class="hljs-keyword">if</span>( h-&gt;param.rc.i_rc_method != X264_RC_CRF )<br>                &#123;<br>                    <span class="hljs-comment">/* Asymmetric clipping, because symmetric would prevent</span><br><span class="hljs-comment">                     * overflow control in areas of rapidly oscillating complexity */</span><br>                    <span class="hljs-type">double</span> lmin = rcc-&gt;last_qscale_for[pict_type] / rcc-&gt;lstep;<br>                    <span class="hljs-type">double</span> lmax = rcc-&gt;last_qscale_for[pict_type] * rcc-&gt;lstep;<br>                    <span class="hljs-keyword">if</span>( overflow &gt; <span class="hljs-number">1.1</span> &amp;&amp; h-&gt;i_frame &gt; <span class="hljs-number">3</span> )<br>                        lmax *= rcc-&gt;lstep;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( overflow &lt; <span class="hljs-number">0.9</span> )<br>                        lmin /= rcc-&gt;lstep;<br><br>                    q = x264_clip3f(q, lmin, lmax);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( h-&gt;param.rc.i_rc_method == X264_RC_CRF &amp;&amp; rcc-&gt;qcompress != <span class="hljs-number">1</span> )<br>            &#123;<br>                q = qp2qscale( ABR_INIT_QP ) / h-&gt;param.rc.f_ip_factor;<br>            &#125;<br>            rcc-&gt;qp_novbv = qscale2qp( q );<br><br>            <span class="hljs-comment">//FIXME use get_diff_limited_q() ?</span><br>            q = clip_qscale( h, pict_type, q );<br>        &#125;<br><br>        rcc-&gt;last_qscale_for[pict_type] =<br>        rcc-&gt;last_qscale = q;<br><br>        <span class="hljs-keyword">if</span>( !(rcc-&gt;b_2pass &amp;&amp; !rcc-&gt;b_vbv) &amp;&amp; h-&gt;fenc-&gt;i_frame == <span class="hljs-number">0</span> )<br>            rcc-&gt;last_qscale_for[SLICE_TYPE_P] = q * h-&gt;param.rc.f_ip_factor;<br><br>        <span class="hljs-keyword">if</span>( rcc-&gt;b_2pass )<br>            rcc-&gt;frame_size_planned = qscale2bits( &amp;rce, q );<br>        <span class="hljs-keyword">else</span><br>            rcc-&gt;frame_size_planned = predict_size( &amp;rcc-&gt;pred[h-&gt;sh.i_type], q, rcc-&gt;last_satd );<br><br>        <span class="hljs-comment">/* Always use up the whole VBV in this case. */</span><br>        <span class="hljs-keyword">if</span>( rcc-&gt;single_frame_vbv )<br>            rcc-&gt;frame_size_planned = rcc-&gt;buffer_rate;<br>        <span class="hljs-comment">/* Limit planned size by MinCR */</span><br>        <span class="hljs-keyword">if</span>( rcc-&gt;b_vbv )<br>            rcc-&gt;frame_size_planned = X264_MIN( rcc-&gt;frame_size_planned, rcc-&gt;frame_size_maximum );<br>        rcc-&gt;frame_size_estimated = rcc-&gt;frame_size_planned;<br>        <span class="hljs-keyword">return</span> q;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据这段代码，可以绘制如下流程图：</p><div align = "center">    <text>rate_estimate_qscale流程图</text>    <img src = "https://nyamori.oss-cn-shanghai.aliyuncs.com/img/rate_estimate_qscale流程图.jpg" width = "100%" height = "100%"  style="border:0;box-shadow: none;">    </img></div> <h5 id="VBV算法"><a href="#VBV算法" class="headerlink" title="VBV算法"></a>VBV算法</h5><p>x264_ratecontrol_start中关于vbv的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>( rc-&gt;b_vbv )<br>&#123;<br>    <span class="hljs-built_in">memset</span>( h-&gt;fdec-&gt;i_row_bits, <span class="hljs-number">0</span>, h-&gt;mb.i_mb_height * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) );<br>    <span class="hljs-built_in">memset</span>( h-&gt;fdec-&gt;f_row_qp, <span class="hljs-number">0</span>, h-&gt;mb.i_mb_height * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>) );<br>    <span class="hljs-built_in">memset</span>( h-&gt;fdec-&gt;f_row_qscale, <span class="hljs-number">0</span>, h-&gt;mb.i_mb_height * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>) );<br>    rc-&gt;row_pred = rc-&gt;row_preds[h-&gt;sh.i_type];<br>    rc-&gt;buffer_rate = h-&gt;fenc-&gt;i_cpb_duration * rc-&gt;vbv_max_rate * h-&gt;sps-&gt;vui.i_num_units_in_tick / h-&gt;sps-&gt;vui.i_time_scale;<br>    update_vbv_plan( h, overhead ); <span class="hljs-comment">//根据当前的帧大小更新vbv</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-type">x264_level_t</span> *l = x264_levels;<br>    <span class="hljs-keyword">while</span>( l-&gt;level_idc != <span class="hljs-number">0</span> &amp;&amp; l-&gt;level_idc != h-&gt;param.i_level_idc )<br>        l++;<br><br>    <span class="hljs-comment">//获取最小的压缩比</span><br>    <span class="hljs-type">int</span> mincr = l-&gt;mincr;<br><br>    <span class="hljs-keyword">if</span>( h-&gt;param.b_bluray_compat )<br>        mincr = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">/* Profiles above High don&#x27;t require minCR, so just set the maximum to a large value. */</span><br>    <span class="hljs-keyword">if</span>( h-&gt;sps-&gt;i_profile_idc &gt; PROFILE_HIGH )<br>        rc-&gt;frame_size_maximum = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* The spec has a bizarre special case for the first frame. 第一帧的特殊处理*/</span><br>        <span class="hljs-keyword">if</span>( h-&gt;i_frame == <span class="hljs-number">0</span> )<br>        &#123;<br>            <span class="hljs-comment">//384 * ( Max( PicSizeInMbs, fR * MaxMBPS ) + MaxMBPS * ( tr( 0 ) - tr,n( 0 ) ) ) / MinCR</span><br>            <span class="hljs-type">double</span> fr = <span class="hljs-number">1.</span> / (h-&gt;param.i_level_idc &gt;= <span class="hljs-number">60</span> ? <span class="hljs-number">300</span> : <span class="hljs-number">172</span>);<br>            <span class="hljs-type">int</span> pic_size_in_mbs = h-&gt;mb.i_mb_width * h-&gt;mb.i_mb_height;<br>            rc-&gt;frame_size_maximum = <span class="hljs-number">384</span> * BIT_DEPTH * X264_MAX( pic_size_in_mbs, fr*l-&gt;mbps ) / mincr;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//384 * MaxMBPS * ( tr( n ) - tr( n - 1 ) ) / MinCR</span><br>            rc-&gt;frame_size_maximum = <span class="hljs-number">384</span> * BIT_DEPTH * ((<span class="hljs-type">double</span>)h-&gt;fenc-&gt;i_cpb_duration * h-&gt;sps-&gt;vui.i_num_units_in_tick / h-&gt;sps-&gt;vui.i_time_scale) * l-&gt;mbps / mincr;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>update_vbv_plan函数如下，可以发现这个函数主要更新了buffer_fill作为计划缓冲区。实际的更新不在这里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// provisionally update VBV according to the planned size of all frames currently in progress</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">update_vbv_plan</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *h, <span class="hljs-type">int</span> overhead )</span><br>&#123;<br>    <span class="hljs-type">x264_ratecontrol_t</span> *rcc = h-&gt;rc;<br>    rcc-&gt;buffer_fill = h-&gt;thread[<span class="hljs-number">0</span>]-&gt;rc-&gt;buffer_fill_final_min / h-&gt;sps-&gt;vui.i_time_scale;<br>    <span class="hljs-comment">//多线程情况</span><br>    <span class="hljs-keyword">if</span>( h-&gt;i_thread_frames &gt; <span class="hljs-number">1</span> )<br>    &#123;<br>        <span class="hljs-type">int</span> j = rcc - h-&gt;thread[<span class="hljs-number">0</span>]-&gt;rc;<br>        <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; h-&gt;i_thread_frames; i++ )<br>        &#123;<br>            <span class="hljs-type">x264_t</span> *t = h-&gt;thread[ (j+i)%h-&gt;i_thread_frames ];<br>            <span class="hljs-type">double</span> bits = t-&gt;rc-&gt;frame_size_planned;<br>            <span class="hljs-keyword">if</span>( !t-&gt;b_thread_active )<br>                <span class="hljs-keyword">continue</span>;<br>            bits = X264_MAX(bits, t-&gt;rc-&gt;frame_size_estimated);<br>            rcc-&gt;buffer_fill -= bits;<br>            rcc-&gt;buffer_fill = X264_MAX( rcc-&gt;buffer_fill, <span class="hljs-number">0</span> );<br>            rcc-&gt;buffer_fill += t-&gt;rc-&gt;buffer_rate;<br>            rcc-&gt;buffer_fill = X264_MIN( rcc-&gt;buffer_fill, rcc-&gt;buffer_size );<br>        &#125;<br>    &#125;<br>    rcc-&gt;buffer_fill = X264_MIN( rcc-&gt;buffer_fill, rcc-&gt;buffer_size );<br>    rcc-&gt;buffer_fill -= overhead;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际的更新在完成编码之后，由x264_ratecontrol_end调用update_vbv;这个函数更新了buffer_fill_final，代表vbv最后实际使用的bits。vbv算法还有许多宏块级的处理，分散在代码中，本次学习暂时没有分析相关内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// update VBV after encoding a frame</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update_vbv</span><span class="hljs-params">( <span class="hljs-type">x264_t</span> *h, <span class="hljs-type">int</span> bits )</span><br>&#123;<br>    <span class="hljs-type">int</span> filler = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> bitrate = h-&gt;sps-&gt;vui.hrd.i_bit_rate_unscaled;<br>    <span class="hljs-type">x264_ratecontrol_t</span> *rcc = h-&gt;rc;<br>    <span class="hljs-type">x264_ratecontrol_t</span> *rct = h-&gt;thread[<span class="hljs-number">0</span>]-&gt;rc;<br>    <span class="hljs-type">int64_t</span> buffer_size = (<span class="hljs-type">int64_t</span>)h-&gt;sps-&gt;vui.hrd.i_cpb_size_unscaled * h-&gt;sps-&gt;vui.i_time_scale;<br><br>    <span class="hljs-keyword">if</span>( rcc-&gt;last_satd &gt;= h-&gt;mb.i_mb_count )<br>        update_predictor( &amp;rct-&gt;pred[h-&gt;sh.i_type], qp2qscale( rcc-&gt;qpa_rc ), rcc-&gt;last_satd, bits );<br><br>    <span class="hljs-keyword">if</span>( !rcc-&gt;b_vbv )<br>        <span class="hljs-keyword">return</span> filler;<br><br>    <span class="hljs-type">uint64_t</span> buffer_diff = (<span class="hljs-type">uint64_t</span>)bits * h-&gt;sps-&gt;vui.i_time_scale;<br>    rct-&gt;buffer_fill_final -= buffer_diff;<br>    rct-&gt;buffer_fill_final_min -= buffer_diff;<br><br>    <span class="hljs-keyword">if</span>( rct-&gt;buffer_fill_final_min &lt; <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-type">double</span> underflow = (<span class="hljs-type">double</span>)rct-&gt;buffer_fill_final_min / h-&gt;sps-&gt;vui.i_time_scale;<br>        <span class="hljs-keyword">if</span>( rcc-&gt;rate_factor_max_increment &amp;&amp; rcc-&gt;qpm &gt;= rcc-&gt;qp_novbv + rcc-&gt;rate_factor_max_increment )<br>            x264_log( h, X264_LOG_DEBUG, <span class="hljs-string">&quot;VBV underflow due to CRF-max (frame %d, %.0f bits)\n&quot;</span>, h-&gt;i_frame, underflow );<br>        <span class="hljs-keyword">else</span><br>            x264_log( h, X264_LOG_WARNING, <span class="hljs-string">&quot;VBV underflow (frame %d, %.0f bits)\n&quot;</span>, h-&gt;i_frame, underflow );<br>        rct-&gt;buffer_fill_final =<br>        rct-&gt;buffer_fill_final_min = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( h-&gt;param.i_avcintra_class )<br>        buffer_diff = buffer_size;<br>    <span class="hljs-keyword">else</span><br>        buffer_diff = (<span class="hljs-type">uint64_t</span>)bitrate * h-&gt;sps-&gt;vui.i_num_units_in_tick * h-&gt;fenc-&gt;i_cpb_duration;<br>    rct-&gt;buffer_fill_final += buffer_diff;<br>    rct-&gt;buffer_fill_final_min += buffer_diff;<br><br>    <span class="hljs-keyword">if</span>( rct-&gt;buffer_fill_final &gt; buffer_size )<br>    &#123;<br>        <span class="hljs-keyword">if</span>( h-&gt;param.rc.b_filler )<br>        &#123;<br>            <span class="hljs-type">int64_t</span> scale = (<span class="hljs-type">int64_t</span>)h-&gt;sps-&gt;vui.i_time_scale * <span class="hljs-number">8</span>;<br>            filler = (rct-&gt;buffer_fill_final - buffer_size + scale - <span class="hljs-number">1</span>) / scale;<br>            bits = h-&gt;param.i_avcintra_class ? filler * <span class="hljs-number">8</span> : X264_MAX( (FILLER_OVERHEAD - h-&gt;param.b_annexb), filler ) * <span class="hljs-number">8</span>;<br>            buffer_diff = (<span class="hljs-type">uint64_t</span>)bits * h-&gt;sps-&gt;vui.i_time_scale;<br>            rct-&gt;buffer_fill_final -= buffer_diff;<br>            rct-&gt;buffer_fill_final_min -= buffer_diff;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            rct-&gt;buffer_fill_final = X264_MIN( rct-&gt;buffer_fill_final, buffer_size );<br>            rct-&gt;buffer_fill_final_min = X264_MIN( rct-&gt;buffer_fill_final_min, buffer_size );<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> filler;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>H.264</tag>
      
      <tag>x264</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Simulcast的新标准-rfc8853笔记</title>
    <link href="/2022/04/18/Simulcast%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86-rfc8853%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/18/Simulcast%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86-rfc8853%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h1><ul><li>2022-04-18 第一次编辑</li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Simulcast基本介绍"><a href="#Simulcast基本介绍" class="headerlink" title="Simulcast基本介绍"></a>Simulcast基本介绍</h2><p>Simulcast可以翻译成多播&#x2F;同播&#x2F;联播，指在RTC应用里面指经过同一个RTP会话（RTP Session）发送同一视频源的不同RTP视频流（RTP Stream）的技术，这些视频流一般拥有不同的帧率、分辨率、码流乃至于编码。</p><p>在WebRTC应用当中，启用Simulcast的客户端会同时启用多个编码器编码多个视频流，并将其发送给SFU，使得与会的其他成员可以根据自己的实际需求要求SFU向自己转发其中一路符合需要的码流。如下图所示：</p><p><img src="https://nyamori.oss-cn-shanghai.aliyuncs.com/img/Simulcast-with-WebRTC.png" alt="在SFU中使用联播"></p><p>传统的联播实现采用了多SSRC的方式，也叫SDP munging。在这种实现方式下，SDP当中会出现<code>a=ssrc-group:SIM ssrc1 ssrc2 ssrc3</code>行，用于描述同一个媒体下的不同视频流。</p><p>目前来看，大多数的WebRTC应用和SFU在支持联播特性的时候使用了这种实现方式。早期的Chrome和Safari都采取了这种实现方式。这种SDP大概是这样的（在chrome:&#x2F;&#x2F;webrtc-internals&#x2F;中可以看到WebRTC的调试信息）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=ssrc:<span class="hljs-number">2639951093</span> cname:hTlM+qeNGeOz6KNK<br><span class="hljs-attribute">a</span>=ssrc:<span class="hljs-number">2639951093</span> msid:bzGeV70XSWsjK6GOPxkKL3qLHglA95aUGSXO d66fcc7b-f965-<span class="hljs-number">4</span>f3d-b7a3-<span class="hljs-number">0</span>ae5ad472d20<br><span class="hljs-attribute">a</span>=ssrc:<span class="hljs-number">2230960165</span> cname:hTlM+qeNGeOz6KNK<br><span class="hljs-attribute">a</span>=ssrc:<span class="hljs-number">2230960165</span> msid:bzGeV70XSWsjK6GOPxkKL3qLHglA95aUGSXO d66fcc7b-f965-<span class="hljs-number">4</span>f3d-b7a3-<span class="hljs-number">0</span>ae5ad472d20<br><span class="hljs-attribute">a</span>=ssrc-group:FID <span class="hljs-number">2639951093</span> <span class="hljs-number">2230960165</span><br><span class="hljs-attribute">a</span>=ssrc:<span class="hljs-number">2639951094</span> cname:hTlM+qeNGeOz6KNK<br><span class="hljs-attribute">a</span>=ssrc:<span class="hljs-number">2639951094</span> msid:bzGeV70XSWsjK6GOPxkKL3qLHglA95aUGSXO d66fcc7b-f965-<span class="hljs-number">4</span>f3d-b7a3-<span class="hljs-number">0</span>ae5ad472d20<br><span class="hljs-attribute">a</span>=ssrc:<span class="hljs-number">2639951095</span> cname:hTlM+qeNGeOz6KNK<br><span class="hljs-attribute">a</span>=ssrc:<span class="hljs-number">2639951095</span> msid:bzGeV70XSWsjK6GOPxkKL3qLHglA95aUGSXO d66fcc7b-f965-<span class="hljs-number">4</span>f3d-b7a3-<span class="hljs-number">0</span>ae5ad472d20<br><span class="hljs-attribute">a</span>=ssrc-group:FID <span class="hljs-number">2639951094</span> <span class="hljs-number">2639951095</span><br><span class="hljs-attribute">a</span>=ssrc:<span class="hljs-number">2639951096</span> cname:hTlM+qeNGeOz6KNK<br><span class="hljs-attribute">a</span>=ssrc:<span class="hljs-number">2639951096</span> msid:bzGeV70XSWsjK6GOPxkKL3qLHglA95aUGSXO d66fcc7b-f965-<span class="hljs-number">4</span>f3d-b7a3-<span class="hljs-number">0</span>ae5ad472d20<br><span class="hljs-attribute">a</span>=ssrc:<span class="hljs-number">2639951097</span> cname:hTlM+qeNGeOz6KNK<br><span class="hljs-attribute">a</span>=ssrc:<span class="hljs-number">2639951097</span> msid:bzGeV70XSWsjK6GOPxkKL3qLHglA95aUGSXO d66fcc7b-f965-<span class="hljs-number">4</span>f3d-b7a3-<span class="hljs-number">0</span>ae5ad472d20<br><span class="hljs-attribute">a</span>=ssrc-group:FID <span class="hljs-number">2639951096</span> <span class="hljs-number">2639951097</span><br><span class="hljs-attribute">a</span>=ssrc-group:SIM <span class="hljs-number">2639951093</span> <span class="hljs-number">2639951094</span> <span class="hljs-number">2639951096</span><br></code></pre></td></tr></table></figure><p>在这段SDP当中<code>a=ssrc-group:FID</code>是绑定FEC的描述行，而<code>a=ssrc-group:SIM</code>则是描述Simulcast信息的描述行。因此可以看到SSRC <code>2639951093</code>、<code>2639951094</code>和<code>2639951096</code>组成了一个联播组，描述了分辨率依次为低、中、高的一组视频流。</p><p>最近在实验Janus的demo的时候，在offer SDP里面就没有携带多SSRC的信息，而是变成了以下类型的SDP：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span>=rid:h send<br><span class="hljs-attr">a</span>=rid:m send<br><span class="hljs-attr">a</span>=rid:l send<br><span class="hljs-attr">a</span>=simulcast:send h<span class="hljs-comment">;m;l</span><br></code></pre></td></tr></table></figure><p>这种SDP看不到SSRC，但是有一个新增的属性rid，看起来描述了三种不同等级的RTP流。janus的answer SDP中也是类似的格式：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span>=rid:h recv<br><span class="hljs-attr">a</span>=rid:m recv<br><span class="hljs-attr">a</span>=rid:l recv<br><span class="hljs-attr">a</span>=simulcast:recv h<span class="hljs-comment">;m;l</span><br></code></pre></td></tr></table></figure><p>这种基于rid的格式现在已经有了一个RFC文档–<a href="https://datatracker.ietf.org/doc/html/rfc8853">rfc8853</a>。</p><h2 id="rfc8853的阅读笔记"><a href="#rfc8853的阅读笔记" class="headerlink" title="rfc8853的阅读笔记"></a>rfc8853的阅读笔记</h2><p>rfc8853的标题是<code> Using Simulcast in Session Description Protocol (SDP) and RTP Sessions</code>，可以看出来是通过SDP和RTP&#x2F;RTCP的扩展完成了联播相关的功能。本节对文档的部分描述进行一些记录。</p><h3 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h3><ul><li>rid即Restriction Identifier，定义在<a href="https://datatracker.ietf.org/doc/html/rfc8851">rfc8851</a>，通过<code>a=rid</code>行和offer&#x2F;answer模式来使得rtp处理者可以去定位某一个特定的rtp流。同时，该行可以做一些比特率，分辨率，帧率相关的描述</li><li><code>a=simulcast</code>行可以指定rid的发送接收方向，<code>;</code>用于分隔属性不同的rid，<code>,</code>用于分隔同类的rid</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rfc</tag>
      
      <tag>rtc</tag>
      
      <tag>rtp</tag>
      
      <tag>sdp</tag>
      
      <tag>rfc8853</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/12/hello-world/"/>
    <url>/2022/04/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>第一次想弄个博客还是2016年，到现在也过去了6年。拖延症实在是可怕，只愿以后这个博客不会荒废。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
